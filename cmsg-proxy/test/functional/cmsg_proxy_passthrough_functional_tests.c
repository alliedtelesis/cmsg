/*
 * Copyright 2017, Allied Telesis Labs New Zealand, Ltd
 *
 * Functional tests for the CMSG proxy library.
 */

#define _GNU_SOURCE
#include <np.h>
#include "cmsg_proxy_passthrough.c"
#include "cmsg_proxy_passthrough_functional_tests_proxy_def.h"
#include "cmsg_proxy_passthrough_functional_tests_api_auto.h"
#include "cmsg_proxy_passthrough_functional_tests_impl_auto.h"

/* *INDENT-OFF* */
char *test_input_json =
    "[\n"
    "    \"string1\",\n"
    "    \"string2\",\n"
    "    \"string3\"\n"
    "]";
/* *INDENT-ON* */

char *test_output_string = "Test is OK";
int test_output_status = 204;

/**
 * Mock the '_cmsg_proxy_library_handles_load' function to simply call
 * the autogenerated 'cmsg_proxy_array_get' and 'cmsg_proxy_array_size'
 * functions that are linked with the executable. Usually the CMSG proxy
 * will dynamically load every '_proxy_def' library that is on the device
 * however to simplify the functional tests we don't do this.
 */
void
sm_mock_cmsg_proxy_passthrough_library_handle_load (const char *library_name)
{
    _load_library_info (cmsg_proxy_array_get, cmsg_proxy_array_size);
}

/**
 * Mock the 'cmsg_create_client_unix' used by the cmsg-proxy to instead be the
 * 'cmsg_create_client_loopback' function. This allows the proxy to execute the
 * CMSG IMPL functions locally which removes the need to run a separate thread/process
 * to implement the CMSG Unix socket server that the proxy usually expects. This makes
 * implementing functional tests much simpler.
 */
cmsg_client *
sm_mock_cmsg_create_client_unix (const ProtobufCServiceDescriptor *descriptor)
{
    return cmsg_create_client_loopback (CMSG_SERVICE_NOPACKAGE (functional_tests));
}

void
functional_tests_impl_passthrough (const void *service, const passthrough_request *recv_msg)
{
    passthrough_response send_msg = PASSTHROUGH_RESPONSE_INIT;

    if (strstr (recv_msg->path, "_get"))
    {
        NP_ASSERT_STR_EQUAL (recv_msg->method, "GET");
    }
    else if (strstr (recv_msg->path, "_put"))
    {
        NP_ASSERT_STR_EQUAL (recv_msg->method, "PUT");
    }
    else if (strstr (recv_msg->path, "_post"))
    {
        NP_ASSERT_STR_EQUAL (recv_msg->method, "POST");
    }
    else if (strstr (recv_msg->path, "_patch"))
    {
        NP_ASSERT_STR_EQUAL (recv_msg->method, "PATCH");
    }
    else
    {
        NP_ASSERT (strstr (recv_msg->path, "_delete"));
        NP_ASSERT_STR_EQUAL (recv_msg->method, "DELETE");
    }

    CMSG_SET_FIELD_PTR (&send_msg, response_body, test_output_string);
    CMSG_SET_FIELD_VALUE (&send_msg, status_code, test_output_status);

    functional_tests_server_passthroughSend (service, &send_msg);
}

int
set_up (void)
{
    np_mock (_cmsg_proxy_passthrough_library_handle_load,
             sm_mock_cmsg_proxy_passthrough_library_handle_load);
    np_mock (cmsg_create_client_unix, sm_mock_cmsg_create_client_unix);

    cmsg_proxy_passthrough_init ("passthrough");
    return 0;
}

int
tear_down (void)
{
    cmsg_proxy_passthrough_deinit ();
    return 0;
}

void
test_simple_passthrough_get (void)
{
    char *output_json = NULL;
    int http_status = 0;

    cmsg_proxy_passthrough ("/test_passthrough_get", NULL, CMSG_HTTP_GET, test_input_json,
                            &output_json, &http_status);

    NP_ASSERT_STR_EQUAL (output_json, test_output_string);
    NP_ASSERT_EQUAL (http_status, test_output_status);

    free (output_json);
}

void
test_simple_passthrough_put (void)
{
    char *output_json = NULL;
    int http_status = 0;

    cmsg_proxy_passthrough ("/test_passthrough_put", NULL, CMSG_HTTP_PUT, test_input_json,
                            &output_json, &http_status);

    NP_ASSERT_STR_EQUAL (output_json, test_output_string);
    NP_ASSERT_EQUAL (http_status, test_output_status);

    free (output_json);
}

void
test_simple_passthrough_post (void)
{
    char *output_json = NULL;
    int http_status = 0;

    cmsg_proxy_passthrough ("/test_passthrough_post", NULL, CMSG_HTTP_POST, test_input_json,
                            &output_json, &http_status);

    NP_ASSERT_STR_EQUAL (output_json, test_output_string);
    NP_ASSERT_EQUAL (http_status, test_output_status);

    free (output_json);
}

void
test_simple_passthrough_patch (void)
{
    char *output_json = NULL;
    int http_status = 0;

    cmsg_proxy_passthrough ("/test_passthrough_patch", NULL, CMSG_HTTP_PATCH,
                            test_input_json, &output_json, &http_status);

    NP_ASSERT_STR_EQUAL (output_json, test_output_string);
    NP_ASSERT_EQUAL (http_status, test_output_status);

    free (output_json);
}

void
test_simple_passthrough_delete (void)
{
    char *output_json = NULL;
    int http_status = 0;

    cmsg_proxy_passthrough ("/test_passthrough_delete", NULL, CMSG_HTTP_DELETE,
                            test_input_json, &output_json, &http_status);

    NP_ASSERT_STR_EQUAL (output_json, test_output_string);
    NP_ASSERT_EQUAL (http_status, test_output_status);

    free (output_json);
}
