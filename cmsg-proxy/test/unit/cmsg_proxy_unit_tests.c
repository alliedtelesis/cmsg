/*
 * Copyright 2016, Allied Telesis Labs New Zealand, Ltd
 */

#define _GNU_SOURCE
#include <np.h>
#include "cmsg_proxy_mem.h"
#include "cmsg_proxy_tree.c"
#include "cmsg_proxy.c"
#include "cmsg_proxy_unit_tests_proxy_def.h"
#include "cmsg_proxy_unit_tests_api_auto.h"

static char *output_json = NULL;
static size_t output_length = 0;
static cmsg_proxy_headers *extra_headers = NULL;

/* Number of nodes expected in the node tree */
#define CMSG_PROXY_EXPECTED_NUM_NODES 30

/* Number of URL/method pairs in the proto file */
#define CMSG_PROXY_NUM_OPERATIONS 17
/* Number of distinct URLs in the proto file */
#define CMSG_PROXY_NUM_DISTINCT_URLS 12

/* Number of URL/method pairs containing "_url" as substring  */
#define CMSG_PROXY_NUM_OPERATIONS_WITH_url 10
/* Number of distinct URLs with "_url" as substring  */
#define CMSG_PROXY_NUM_DISTINCT_URLS_WITH_url 6

/* Number of URL/method pairs containing "_url" as substring  */
#define CMSG_PROXY_NUM_OPERATIONS_WITH_all_methods_url 5
/* Number of distinct URLs with "_url" as substring  */
#define CMSG_PROXY_NUM_DISTINCT_URLS_WITH_all_methods_url 1

/* Number of URL/method pairs containing "{field_a}" as substring  */
#define CMSG_PROXY_NUM_OPERATIONS_WITH_field_a 2
/* Number of distinct URLs with "{field_a}" as substring  */
#define CMSG_PROXY_NUM_DISTINCT_URLS_WITH_field_a 2

#define CMSG_PROXY_INDEX_BASEPATH_KEY "basepath"
#define CMSG_PROXY_INDEX_PATHS_KEY "paths"
#define CMSG_PROXY_INDEX_PATH_KEY "path"
#define CMSG_PROXY_INDEX_METHODS_KEY "methods"

static const char *mime_type = NULL;

void
setup_standard_test_tree (void)
{
    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));
    _cmsg_proxy_service_info_init (cmsg_proxy_array_get (), cmsg_proxy_array_size ());
}

int
tear_down (void)
{
    free (output_json);
    output_json = NULL;

    if (proxy_entries_tree)
    {
        _cmsg_proxy_service_info_deinit ();
    }

    return 0;
}

/**
 * Function Tested: _cmsg_proxy_service_info_init()
 *
 * Tests that the proxy tree is the correct length after _cmsg_proxy_service_info_init()
 * is called. Given the following set of RPCs:
 * PUT: /v1/test
 * GET: /v1/test
 * GET: /v1/test/test1
 * GET: /v1/test/query_param/{key_a}/{key_c}
 *
 * the resulting proxy tree will have a total of 10 nodes:
 *                  ---PUT
 *                 /
 *                /----GET
 *               /
 * "v1"---"test"-------"test1"---GET
 *               \
 *                -----"query_param"---"{key_a}"---"{key_c}"---GET
 *
 * N.B. The number of entries in the tree has increased since this test was written. The
 * size of the tree is stored in the define CMSG_PROXY_EXPECTED_NUM_NODES
 */
void
test_cmsg_proxy_service_info_init__list_length (void)
{
    setup_standard_test_tree ();
    NP_ASSERT_EQUAL (g_node_n_nodes (proxy_entries_tree, G_TRAVERSE_ALL),
                     CMSG_PROXY_EXPECTED_NUM_NODES);

    _cmsg_proxy_service_info_init (cmsg_proxy_array_get (), cmsg_proxy_array_size ());
    NP_ASSERT_EQUAL (g_node_n_nodes (proxy_entries_tree, G_TRAVERSE_ALL),
                     CMSG_PROXY_EXPECTED_NUM_NODES);

    _cmsg_proxy_service_info_init (cmsg_proxy_array_get (), cmsg_proxy_array_size ());
    NP_ASSERT_EQUAL (g_node_n_nodes (proxy_entries_tree, G_TRAVERSE_ALL),
                     CMSG_PROXY_EXPECTED_NUM_NODES);
}

/**
 * Function Tested: _cmsg_proxy_service_info_init()
 *
 * Tests that the first proxy list entry points at the expected autogenerated data.
 */
void
test_cmsg_proxy_service_info_init__list_entries (void)
{
    setup_standard_test_tree ();
    const cmsg_service_info *entry =
        _cmsg_proxy_find_service_from_url_and_verb ("/v1/test", CMSG_HTTP_PUT, NULL);

    NP_ASSERT_PTR_EQUAL (entry, cmsg_proxy_array_get ());
    NP_ASSERT_PTR_EQUAL (entry->service_descriptor,
                         &cmsg_proxy_unit_tests_interface_descriptor);
    NP_ASSERT_EQUAL (entry->http_verb, CMSG_HTTP_PUT);
}

/**
 * Function Tested: _cmsg_proxy_find_service_from_url_and_verb()
 *
 * Tests that the function finds the correct service entry when passed
 * a known URL and verb or returns NULL for an unknown URL and verb.
 */
void
test_cmsg_proxy_find_service_from_url_and_verb__finds_correct_service_entry (void)
{
    const cmsg_service_info *entry;
    GList *url_parameters = NULL;

    setup_standard_test_tree ();

    entry = _cmsg_proxy_find_service_from_url_and_verb ("/v1/test", CMSG_HTTP_PUT,
                                                        &url_parameters);
    NP_ASSERT_PTR_NOT_EQUAL (entry, NULL);
    NP_ASSERT_EQUAL (entry->http_verb, CMSG_HTTP_PUT);

    entry = _cmsg_proxy_find_service_from_url_and_verb ("BAD URL", CMSG_HTTP_PUT,
                                                        &url_parameters);
    NP_ASSERT_PTR_EQUAL (entry, NULL);

    entry = _cmsg_proxy_find_service_from_url_and_verb ("/v1/test", CMSG_HTTP_GET,
                                                        &url_parameters);
    NP_ASSERT_PTR_NOT_EQUAL (entry, NULL);
    NP_ASSERT_EQUAL (entry->http_verb, CMSG_HTTP_GET);

    entry = _cmsg_proxy_find_service_from_url_and_verb ("/v1/test", CMSG_HTTP_PATCH,
                                                        &url_parameters);
    NP_ASSERT_PTR_EQUAL (entry, NULL);

    g_list_free_full (url_parameters, _cmsg_proxy_free_url_parameter);
}

/**
 * Function Tested: _cmsg_proxy_convert_json_to_protobuf()
 *
 * Tests that valid input is correctly converted into a protobuf message
 */
void
test_cmsg_proxy_convert_json_to_protobuf__valid_input (void)
{
    ProtobufCMessage *output = NULL;
    bool ret;
    json_error_t error;
    char *error_message = NULL;
    json_t *json_obj = json_loads ("{\n    \"value\":true\n}", 0, &error);

    ret = _cmsg_proxy_convert_json_to_protobuf (json_obj,
                                                &cmsg_proxy_unit_tests_cmsg_bool_descriptor,
                                                &output, &error_message);

    json_decref (json_obj);
    free (output);
    if (error_message)
    {
        free (error_message);
        error_message = NULL;
    }
    NP_ASSERT_TRUE (ret == 0);
}

/**
 * Function Tested: _cmsg_proxy_convert_json_to_protobuf()
 *
 * Tests that invalid input fails to be converted into a protobuf message
 */
void
test_cmsg_proxy_convert_json_to_protobuf__invalid_input (void)
{
    ProtobufCMessage *output = NULL;
    int ret;
    json_error_t error;
    json_t *json_obj;
    char *error_message = NULL;

    /* value is not quoted correctly */
    json_obj = json_loads ("{\n    value\":true\n}", 0, &error);

    ret = _cmsg_proxy_convert_json_to_protobuf (json_obj,
                                                &cmsg_proxy_unit_tests_cmsg_bool_descriptor,
                                                &output, &error_message);

    if (error_message)
    {
        free (error_message);
        error_message = NULL;
    }

    NP_ASSERT_FALSE (ret == 0);
    json_decref (json_obj);

    /* json string is missing closing bracket */
    json_obj = json_loads ("{\n    \"value\":true\n", 0, &error);

    ret = _cmsg_proxy_convert_json_to_protobuf (json_obj,
                                                &cmsg_proxy_unit_tests_cmsg_bool_descriptor,
                                                &output, &error_message);

    if (error_message)
    {
        free (error_message);
        error_message = NULL;
    }

    json_decref (json_obj);
    NP_ASSERT_FALSE (ret == 0);
}

/**
 * Function Tested: _cmsg_proxy_create_client()
 *
 * Tests that the function correctly creates a CMSG client
 * from a valid descriptor
 */
void
test_cmsg_proxy_create_client (void)
{
    _cmsg_proxy_create_client (&cmsg_proxy_unit_tests_interface_descriptor);

    NP_ASSERT_EQUAL (g_list_length (proxy_clients_list), 1);
}

struct cmsg_client *
sm_mock_cmsg_create_client_unix__returns_null (const ProtobufCServiceDescriptor *descriptor)
{
    return NULL;
}

/**
 * Function Tested: _cmsg_proxy_create_client()
 *
 * Tests that no memory is leaked if the internal cmsg_create_client_unix()
 * function fails
 */
void
test_cmsg_proxy_create_client__memory_leaks (void)
{
    np_mock (cmsg_create_client_unix, sm_mock_cmsg_create_client_unix__returns_null);

    np_syslog_ignore ("Failed to create client for service:");

    _cmsg_proxy_create_client (&cmsg_proxy_unit_tests_interface_descriptor);
    _cmsg_proxy_create_client (&cmsg_proxy_unit_tests_interface_descriptor);

    NP_ASSERT_EQUAL (g_list_length (proxy_clients_list), 0);
}

/**
 * Function Tested: _cmsg_proxy_clients_init()
 *
 * Tests that the function correctly creates the required CMSG clients
 */
void
test_cmsg_proxy_clients_init (void)
{
    setup_standard_test_tree ();

    _cmsg_proxy_clients_init ();
    NP_ASSERT_EQUAL (g_list_length (proxy_clients_list), 1);

    _cmsg_proxy_clients_init ();
    NP_ASSERT_EQUAL (g_list_length (proxy_clients_list), 1);
}

/**
 * Function Tested: protobuf2json_string()
 *
 * Tests that valid input is correctly converted into a json string
 */
void
test_cmsg_proxy_protobuf2json_string (void)
{
    cmsg_proxy_unit_tests_cmsg_bool proto_msg = CMSG_PROXY_UNIT_TESTS_CMSG_BOOL_INIT;
    char *json_str = NULL;
    bool ret = false;

    CMSG_SET_FIELD_VALUE (&proto_msg, value, true);

    ret = protobuf2json_string ((ProtobufCMessage *) &proto_msg, JSON_INDENT (4),
                                &json_str, NULL, 0);

    NP_ASSERT_EQUAL (ret, 0);
    NP_ASSERT_STR_EQUAL (json_str, "{\n    \"value\": true\n}");

    free (json_str);
}

/**
 * Function Tested: protobuf2json_string()
 *
 * Tests that a NULL repeated field is converted into an empty JSON array.
 */
void
test_cmsg_proxy_protobuf2json_string_NULL_repeated (void)
{
    cmsg_proxy_unit_tests_cmsg_uint32_array proto_msg =
        CMSG_PROXY_UNIT_TESTS_CMSG_UINT32_ARRAY_INIT;
    char *json_str = NULL;
    bool ret = false;

    ret = protobuf2json_string ((ProtobufCMessage *) &proto_msg, JSON_INDENT (4),
                                &json_str, NULL, 0);

    NP_ASSERT_EQUAL (ret, 0);
    NP_ASSERT_STR_EQUAL (json_str, "{\n    \"values\": []\n}");

    free (json_str);
}

/**
 * Function Tested: _cmsg_proxy_service_info_add()
 *
 * Tests that input URL string is correctly tokenized into the tree
 */
void
test_cmsg_proxy_service_info_add (void)
{
    cmsg_service_info *array = cmsg_proxy_array_get ();

    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));

    _cmsg_proxy_service_info_add (&array[2]);
    NP_ASSERT_EQUAL (g_node_n_nodes (proxy_entries_tree, G_TRAVERSE_ALL), 5);

    _cmsg_proxy_service_info_add (&array[0]);
    NP_ASSERT_EQUAL (g_node_n_nodes (proxy_entries_tree, G_TRAVERSE_ALL), 6);

    /* Add the same service info again. */
    _cmsg_proxy_service_info_add (&array[0]);
    NP_ASSERT_EQUAL (g_node_n_nodes (proxy_entries_tree, G_TRAVERSE_ALL), 6);

    /* Add the different service info with same URL. */
    _cmsg_proxy_service_info_add (&array[1]);
    NP_ASSERT_EQUAL (g_node_n_nodes (proxy_entries_tree, G_TRAVERSE_ALL), 6);
}

/**
 * Function Tested: _cmsg_proxy_deinit()
 *
 * Tests that dynamically allocated memory is freed properly
 */
void
test_cmsg_proxy_deinit (void)
{
    setup_standard_test_tree ();

    _cmsg_proxy_clients_init ();
    NP_ASSERT_EQUAL (g_list_length (proxy_clients_list), 1);

    cmsg_proxy_deinit ();
    NP_ASSERT_PTR_EQUAL (proxy_clients_list, NULL);
    NP_ASSERT_PTR_EQUAL (proxy_entries_tree, NULL);
    NP_ASSERT_PTR_EQUAL (library_handles_list, NULL);
}

/**
 * Function Tested: cmsg_proxy()
 *
 * Tests that invalid JSON input is appropriately handled.
 */
void
test_cmsg_proxy__invalid_json_input (void)
{
    bool request_handled;
    int http_status;

    /* *INDENT-OFF* */
    char *expected_output_json =
        "{"
        "\"code\":\"ANT_CODE_INVALID_ARGUMENT\","
        "\"message\":\"Invalid JSON: string or '}' expected near end of file\""
        "}";
    /* *INDENT-ON* */

    setup_standard_test_tree ();

    request_handled =
        cmsg_proxy ("/v1/test", NULL, CMSG_HTTP_PUT, "{", strlen ("{"), NULL, &output_json,
                    &output_length, &mime_type, &extra_headers, &http_status);

    NP_ASSERT_TRUE (request_handled);
    NP_ASSERT_STR_EQUAL (output_json, expected_output_json);
    NP_ASSERT_EQUAL (http_status, 400);
}

/**
 * Function Tested: _cmsg_proxy_parse_query_parameters()
 *
 * Tests that a query string is correctly parsed and that any parsed query
 * parameters do not overwrite parameters with identical keys already in the list.
 */
void
test_cmsg_proxy_parse_query_parameters (void)
{
    GList *url_parameters = NULL;
    GList *matching_param = NULL;

    setup_standard_test_tree ();

    /* URL: /v1/test/query_param/{key_a}/{key_c} */
    _cmsg_proxy_get_service_and_parameters ("/v1/test/query_param/AA/CC",
                                            "key_a=WW&key_b=XX&key_c=YY&key_d=ZZ",
                                            CMSG_HTTP_GET, &url_parameters);

    /* There should be 4 parameters in the list (skip duplicate keys) */
    NP_ASSERT_EQUAL (g_list_length (url_parameters), 4);

    /* The parameter values for "key_a" and "key_c" should be "AA" and "CC" as
     * set in the URL. */
    matching_param = g_list_find_custom (url_parameters, "key_a",
                                         _cmsg_proxy_param_name_matches);
    NP_ASSERT_STR_EQUAL (((cmsg_url_parameter *) matching_param->data)->value, "AA");
    matching_param = g_list_find_custom (url_parameters, "key_c",
                                         _cmsg_proxy_param_name_matches);
    NP_ASSERT_STR_EQUAL (((cmsg_url_parameter *) matching_param->data)->value, "CC");

    /* The parameter values for "key_b" and "key_d" should match the values
     * provided in the query string, "XX" and "ZZ" */
    matching_param = g_list_find_custom (url_parameters, "key_b",
                                         _cmsg_proxy_param_name_matches);
    NP_ASSERT_STR_EQUAL (((cmsg_url_parameter *) matching_param->data)->value, "XX");
    matching_param = g_list_find_custom (url_parameters, "key_d",
                                         _cmsg_proxy_param_name_matches);
    NP_ASSERT_STR_EQUAL (((cmsg_url_parameter *) matching_param->data)->value, "ZZ");

    g_list_free_full (url_parameters, _cmsg_proxy_free_url_parameter);
}

/**
 * Function Tested: _cmsg_proxy_find_service_from_url_and_verb()
 *
 * Tests that the function returns a service info entry for an RPC's
 * URL and each of its additional bindings, and that they all point to
 * the same API function.
 */
void
test_cmsg_proxy_find_service_from_url_and_verb__additional_bindings_use_same_api (void)
{
    GList *url_parameters = NULL;
    const cmsg_service_info *entry1;
    const cmsg_service_info *entry2;
    const cmsg_service_info *entry3;
    const char *url1 = "/v1/test/additional_bindings/test_get/value_a/value_b";
    const char *url2 = "/v1/test/additional_bindings/test_post";
    const char *url3 = "/v1/test/additional_bindings/test_get/value_a";

    setup_standard_test_tree ();

    entry1 = _cmsg_proxy_find_service_from_url_and_verb (url1, CMSG_HTTP_GET,
                                                         &url_parameters);
    NP_ASSERT_PTR_NOT_EQUAL (entry1, NULL);
    NP_ASSERT_PTR_EQUAL (entry1->api_ptr,
                         &cmsg_proxy_unit_tests_interface_api_test_additional_bindings);
    NP_ASSERT_EQUAL (entry1->http_verb, CMSG_HTTP_GET);

    entry2 = _cmsg_proxy_find_service_from_url_and_verb (url2, CMSG_HTTP_POST,
                                                         &url_parameters);
    NP_ASSERT_PTR_NOT_EQUAL (entry2, NULL);
    NP_ASSERT_PTR_EQUAL (entry2->api_ptr,
                         &cmsg_proxy_unit_tests_interface_api_test_additional_bindings);
    NP_ASSERT_EQUAL (entry2->http_verb, CMSG_HTTP_POST);

    entry3 = _cmsg_proxy_find_service_from_url_and_verb (url3, CMSG_HTTP_GET,
                                                         &url_parameters);
    NP_ASSERT_PTR_NOT_EQUAL (entry3, NULL);
    NP_ASSERT_PTR_EQUAL (entry3->api_ptr,
                         &cmsg_proxy_unit_tests_interface_api_test_additional_bindings);
    NP_ASSERT_EQUAL (entry3->http_verb, CMSG_HTTP_GET);

    g_list_free_full (url_parameters, _cmsg_proxy_free_url_parameter);
}

static bool
_pre_api_check_dummy (cmsg_http_verb http_verb, char **message)
{
    return true;
}

/**
 * Function Tested: cmsg_proxy_set_pre_api_http_check_callback()
 *
 * Tests that the function correctly sets the pre_api_check_callback
 * function pointer to the function that is passed in.
 */
void
test_cmsg_proxy_set_pre_api_http_check_callback (void)
{
    cmsg_proxy_set_pre_api_http_check_callback (_pre_api_check_dummy);
    NP_ASSERT_PTR_EQUAL (pre_api_check_callback, _pre_api_check_dummy);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that for a standard call with default correct arguments, the function returns
 * HTTP_CODE_OK.
 */
void
test_cmsg_proxy_index__returns_http_ok (void)
{
    int http_ret;

    setup_standard_test_tree ();
    http_ret = cmsg_proxy_index (NULL, &output_json, &output_length);

    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that for a standard call with default correct arguments, the returned object
 * includes exactly two fields named "basepath" and "paths".
 */
void
test_cmsg_proxy_index__json_object_contains_correct_fields (void)
{
    json_t *json_obj, *paths, *basepath;
    int http_ret;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index (NULL, &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
    NP_ASSERT_NOT_NULL (output_json);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);

    basepath = json_object_get (json_obj, CMSG_PROXY_INDEX_BASEPATH_KEY);
    NP_ASSERT_NOT_NULL (basepath);

    NP_ASSERT_EQUAL (json_object_size (json_obj), 2);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that for a standard call with default correct arguments, the function returns
 * the expected number of URLs and the expected total number of operations (sum of array
 * size of all method arrays).
 */
void
test_cmsg_proxy_index__returns_all_entries (void)
{
    json_t *json_obj, *paths, *url, *methods;
    int http_ret;
    int operation_count = 0;
    int i;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index (NULL, &output_json, &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), CMSG_PROXY_NUM_DISTINCT_URLS);

    json_array_foreach (paths, i, url)
    {
        methods = json_object_get (url, CMSG_PROXY_INDEX_METHODS_KEY);
        NP_ASSERT_NOT_NULL (methods);
        operation_count += json_array_size (methods);
    }
    NP_ASSERT_EQUAL (operation_count, CMSG_PROXY_NUM_OPERATIONS);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that if a search query string is used that doesn't include braces ("_url"),
 * the function returns all and only matching operations. Checks that the number of URLs
 * and the total number of operations (sum of array size of the returned method arrays) are
 * the expected values.
 */
void
test_cmsg_proxy_index__returns_search_no_braces (void)
{
    json_t *json_obj, *paths, *url, *methods;
    int http_ret;
    int operation_count = 0;
    int i;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("search_string=_url", &output_json, &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), CMSG_PROXY_NUM_DISTINCT_URLS_WITH_url);

    json_array_foreach (paths, i, url)
    {
        methods = json_object_get (url, CMSG_PROXY_INDEX_METHODS_KEY);
        NP_ASSERT_NOT_NULL (methods);
        operation_count += json_array_size (methods);
    }
    NP_ASSERT_EQUAL (operation_count, CMSG_PROXY_NUM_OPERATIONS_WITH_url);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that if a search query string is used that does include braces ("{field_a}"),
 * the function returns all and only matching operations. Checks that the number of URLs
 * and the total number of operations (sum of array size of the returned method arrays) are
 * the expected values.  The input is URL Encoded.
 */
void
test_cmsg_proxy_index__returns_search_with_braces (void)
{
    json_t *json_obj, *paths, *url, *methods;
    int http_ret;
    int operation_count = 0;
    int i;

    setup_standard_test_tree ();

    http_ret =
        cmsg_proxy_index ("search_string=%7Bfield_a%7D", &output_json, &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), CMSG_PROXY_NUM_DISTINCT_URLS_WITH_field_a);

    json_array_foreach (paths, i, url)
    {
        methods = json_object_get (url, CMSG_PROXY_INDEX_METHODS_KEY);
        NP_ASSERT_NOT_NULL (methods);
        operation_count += json_array_size (methods);
    }
    NP_ASSERT_EQUAL (operation_count, CMSG_PROXY_NUM_OPERATIONS_WITH_field_a);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that if an unknown query string is used (something other than search), it is
 * ignored and  the function returns all operations. Checks that the number of URLs
 * and the total number of operations (sum of array size of the returned method arrays) are
 * the expected values.
 */
void
test_cmsg_proxy_index__unknown_query_ignored (void)
{
    json_t *json_obj, *paths, *url, *methods;
    int http_ret;
    int operation_count = 0;
    int i;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("blah=_url", &output_json, &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), CMSG_PROXY_NUM_DISTINCT_URLS);

    json_array_foreach (paths, i, url)
    {
        methods = json_object_get (url, CMSG_PROXY_INDEX_METHODS_KEY);
        NP_ASSERT_NOT_NULL (methods);
        operation_count += json_array_size (methods);
    }
    NP_ASSERT_EQUAL (operation_count, CMSG_PROXY_NUM_OPERATIONS);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that if a search query string is supplied, but preceded by an unknown query string
 * the function returns all and only operations that match the search query string.
 * Checks that the number of URLs and the total number of operations (sum of array size of
 * the returned method arrays) are the expected values.
 */
void
test_cmsg_proxy_index__returns_search_unknown_query_before (void)
{
    json_t *json_obj, *paths, *url, *methods;
    int http_ret;
    int operation_count = 0;
    int i;

    setup_standard_test_tree ();

    http_ret =
        cmsg_proxy_index ("blah=something&search_string=_url", &output_json,
                          &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), CMSG_PROXY_NUM_DISTINCT_URLS_WITH_url);

    json_array_foreach (paths, i, url)
    {
        methods = json_object_get (url, CMSG_PROXY_INDEX_METHODS_KEY);
        NP_ASSERT_NOT_NULL (methods);
        operation_count += json_array_size (methods);
    }
    NP_ASSERT_EQUAL (operation_count, CMSG_PROXY_NUM_OPERATIONS_WITH_url);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that if a search query string is supplied, but followed by an unknown query string
 * the function returns all and only operations that match the search query string.
 * Checks that the number of URLs and the total number of operations (sum of array size of
 * the returned method arrays) are the expected values.
 */
void
test_cmsg_proxy_index__returns_search_unknown_query_after (void)
{
    json_t *json_obj, *paths, *url, *methods;
    int http_ret;
    int operation_count = 0;
    int i;

    setup_standard_test_tree ();

    http_ret =
        cmsg_proxy_index ("search_string=_url&blah=something", &output_json,
                          &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), CMSG_PROXY_NUM_DISTINCT_URLS_WITH_url);

    json_array_foreach (paths, i, url)
    {
        methods = json_object_get (url, CMSG_PROXY_INDEX_METHODS_KEY);
        NP_ASSERT_NOT_NULL (methods);
        operation_count += json_array_size (methods);
    }
    NP_ASSERT_EQUAL (operation_count, CMSG_PROXY_NUM_OPERATIONS_WITH_url);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that if two search query strings are supplied, the second is ignored.
 * Checks that the number of URLs and the total number of operations (sum of array size of
 * the returned method arrays) are the expected values. As the second search is a superset
 * of the first, if the second was used, the number of returned operations would be larger.
 */
void
test_cmsg_proxy_index__returns_first_search (void)
{
    json_t *json_obj, *paths, *url, *methods;
    int http_ret;
    int operation_count = 0;
    int i;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("search_string=all_methods_url&search_string=_url",
                                 &output_json, &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths),
                     CMSG_PROXY_NUM_DISTINCT_URLS_WITH_all_methods_url);

    json_array_foreach (paths, i, url)
    {
        methods = json_object_get (url, CMSG_PROXY_INDEX_METHODS_KEY);
        NP_ASSERT_NOT_NULL (methods);
        operation_count += json_array_size (methods);
    }
    NP_ASSERT_EQUAL (operation_count, CMSG_PROXY_NUM_OPERATIONS_WITH_all_methods_url);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Tests that if an empty search query string is supplied, all operations are returned.
 * Checks that the number of URLs and the total number of operations (sum of array size of
 * the returned method arrays) are the expected values.
 */
void
test_cmsg_proxy_index__returns_all_entries_with_empty_search (void)
{
    json_t *json_obj, *paths, *url, *methods;
    int http_ret;
    int operation_count = 0;
    int i;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("search_string=", &output_json, &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), CMSG_PROXY_NUM_DISTINCT_URLS);

    json_array_foreach (paths, i, url)
    {
        methods = json_object_get (url, CMSG_PROXY_INDEX_METHODS_KEY);
        NP_ASSERT_NOT_NULL (methods);
        operation_count += json_array_size (methods);
    }
    NP_ASSERT_EQUAL (operation_count, CMSG_PROXY_NUM_OPERATIONS);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Check that the function returns an empty array for paths and still sets the basepath
 * if no search matches are found
 */
void
test_cmsg_proxy_index__returns_empty_array_when_no_search_match (void)
{
    json_t *json_obj, *paths, *basepath;
    int http_ret;

    setup_standard_test_tree ();

    http_ret =
        cmsg_proxy_index ("search_string=UnlikelyURLSubstring", &output_json,
                          &output_length);
    NP_ASSERT_NOT_NULL (output_json);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), 0);

    basepath = json_object_get (json_obj, CMSG_PROXY_INDEX_BASEPATH_KEY);
    NP_ASSERT_NOT_NULL (basepath);

    NP_ASSERT_EQUAL (json_object_size (json_obj), 2);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that a URL for which there is only a get operation sets the URL string in the index
 * correctly and that the method string is exactly "GET"
 */
void
test_cmsg_proxy_index__get_method_is_GET_and_sets_url (void)
{
    json_t *json_obj, *paths, *api, *methods, *method, *path;
    int http_ret;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("search_string=get_url", &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
    NP_ASSERT_NOT_NULL (output_json);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), 1);

    api = json_array_get (paths, 0);
    methods = json_object_get (api, CMSG_PROXY_INDEX_METHODS_KEY);
    NP_ASSERT_EQUAL (json_array_size (methods), 1);

    method = json_array_get (methods, 0);
    NP_ASSERT_STR_EQUAL (json_string_value (method), "GET");

    path = json_object_get (api, CMSG_PROXY_INDEX_PATH_KEY);
    NP_ASSERT_NOT_NULL (path);
    NP_ASSERT_STR_EQUAL (json_string_value (path), "/v1/test/get_url");

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that a URL for which there is only a put operation sets the URL string in the index
 * correctly and that the method string is exactly "PUT"
 */
void
test_cmsg_proxy_index__put_method_is_PUT_and_sets_url (void)
{
    json_t *json_obj, *paths, *api, *methods, *method, *path;
    int http_ret;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("search_string=put_url", &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
    NP_ASSERT_NOT_NULL (output_json);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), 1);

    api = json_array_get (paths, 0);
    methods = json_object_get (api, CMSG_PROXY_INDEX_METHODS_KEY);
    NP_ASSERT_EQUAL (json_array_size (methods), 1);

    method = json_array_get (methods, 0);
    NP_ASSERT_STR_EQUAL (json_string_value (method), "PUT");

    path = json_object_get (api, CMSG_PROXY_INDEX_PATH_KEY);
    NP_ASSERT_NOT_NULL (path);
    NP_ASSERT_STR_EQUAL (json_string_value (path), "/v1/test/put_url");

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that a URL for which there is only a post operation sets the URL string in the index
 * correctly and that the method string is exactly "POST"
 */
void
test_cmsg_proxy_index__post_method_is_POST_and_sets_url (void)
{
    json_t *json_obj, *paths, *api, *methods, *method, *path;
    int http_ret;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("search_string=post_url", &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
    NP_ASSERT_NOT_NULL (output_json);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), 1);

    api = json_array_get (paths, 0);
    methods = json_object_get (api, CMSG_PROXY_INDEX_METHODS_KEY);
    NP_ASSERT_EQUAL (json_array_size (methods), 1);

    method = json_array_get (methods, 0);
    NP_ASSERT_STR_EQUAL (json_string_value (method), "POST");

    path = json_object_get (api, CMSG_PROXY_INDEX_PATH_KEY);
    NP_ASSERT_NOT_NULL (path);
    NP_ASSERT_STR_EQUAL (json_string_value (path), "/v1/test/post_url");

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that a URL for which there is only a patch operation sets the URL string in the
 * index correctly and that the method string is exactly "PATCH"
 */
void
test_cmsg_proxy_index__patch_method_is_PATCH_and_sets_url (void)
{
    json_t *json_obj, *paths, *api, *methods, *method, *path;
    int http_ret;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("search_string=patch_url", &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
    NP_ASSERT_NOT_NULL (output_json);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), 1);

    api = json_array_get (paths, 0);
    methods = json_object_get (api, CMSG_PROXY_INDEX_METHODS_KEY);
    NP_ASSERT_EQUAL (json_array_size (methods), 1);

    method = json_array_get (methods, 0);
    NP_ASSERT_STR_EQUAL (json_string_value (method), "PATCH");

    path = json_object_get (api, CMSG_PROXY_INDEX_PATH_KEY);
    NP_ASSERT_NOT_NULL (path);
    NP_ASSERT_STR_EQUAL (json_string_value (path), "/v1/test/patch_url");

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that a URL for which there is only a delete operation sets the URL string in the
 * index correctly and that the method string is exactly "DELETE"
 */
void
test_cmsg_proxy_index__delete_method_is_DELETE_and_sets_url (void)
{
    json_t *json_obj, *paths, *api, *methods, *method, *path;
    int http_ret;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index ("search_string=delete_url", &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
    NP_ASSERT_NOT_NULL (output_json);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), 1);

    api = json_array_get (paths, 0);
    methods = json_object_get (api, CMSG_PROXY_INDEX_METHODS_KEY);
    NP_ASSERT_EQUAL (json_array_size (methods), 1);

    method = json_array_get (methods, 0);
    NP_ASSERT_STR_EQUAL (json_string_value (method), "DELETE");

    path = json_object_get (api, CMSG_PROXY_INDEX_PATH_KEY);
    NP_ASSERT_NOT_NULL (path);
    NP_ASSERT_STR_EQUAL (json_string_value (path), "/v1/test/delete_url");

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that a URL that has operations for all methods, returns all the methods and returns
 * them in the same (alphabetical) order.
 */
void
test_cmsg_proxy_index__can_return_all_methods_alphabetical (void)
{
    json_t *json_obj, *paths, *api, *methods, *method, *path;
    int http_ret;
    const char *alphabetical_http_methods[] = { "DELETE", "GET", "PATCH", "POST", "PUT" };
    int i;

    setup_standard_test_tree ();

    http_ret =
        cmsg_proxy_index ("search_string=all_methods_url", &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
    NP_ASSERT_NOT_NULL (output_json);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    paths = json_object_get (json_obj, CMSG_PROXY_INDEX_PATHS_KEY);
    NP_ASSERT_NOT_NULL (paths);
    NP_ASSERT_EQUAL (json_array_size (paths), 1);

    api = json_array_get (paths, 0);
    methods = json_object_get (api, CMSG_PROXY_INDEX_METHODS_KEY);
    NP_ASSERT_EQUAL (json_array_size (methods), 5);

    json_array_foreach (methods, i, method)
    {
        NP_ASSERT_STR_EQUAL (json_string_value (method), alphabetical_http_methods[i]);
    }

    path = json_object_get (api, CMSG_PROXY_INDEX_PATH_KEY);
    NP_ASSERT_NOT_NULL (path);
    NP_ASSERT_STR_EQUAL (json_string_value (path), "/v1/test/all_methods_url");

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that the basepath is set to the define API_PREFIX.
 */
void
test_cmsg_proxy_index__api_prefix_in_basepath (void)
{
    json_t *json_obj, *basepath;
    int http_ret;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index (NULL, &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_OK);
    NP_ASSERT_NOT_NULL (output_json);

    json_obj = json_loads (output_json, 0, NULL);
    NP_ASSERT_NOT_NULL (json_obj);

    basepath = json_object_get (json_obj, CMSG_PROXY_INDEX_BASEPATH_KEY);
    NP_ASSERT_NOT_NULL (basepath);
    NP_ASSERT_STR_EQUAL (json_string_value (basepath), API_PREFIX);

    json_decref (json_obj);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that calling the function before the node tree is initialised returns
 * HTTP_CODE_INTERNAL_SERVER_ERROR.
 */
void
test_cmsg_proxy_index__before_tree_init_returns_error (void)
{
    int http_ret;

    http_ret = cmsg_proxy_index (NULL, &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_INTERNAL_SERVER_ERROR);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that calling the function before the node tree is initialised returns
 * HTTP_CODE_INTERNAL_SERVER_ERROR. This time with a query string to catch memory leaks.
 */
void
test_cmsg_proxy_index__before_tree_init_returns_error_with_query_string (void)
{
    int http_ret;

    http_ret = cmsg_proxy_index ("search_string=_url", &output_json, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_INTERNAL_SERVER_ERROR);
}

/**
 * Function Tested: cmsg_proxy_index ()
 *
 * Test that calling the function with NULL in the output_json parameter returns
 * HTTP_CODE_INTERNAL_SERVER_ERROR.
 */
void
test_cmsg_proxy_index__output_json_NULL_returns_error (void)
{
    int http_ret;

    setup_standard_test_tree ();

    http_ret = cmsg_proxy_index (NULL, NULL, &output_length);
    NP_ASSERT_EQUAL (http_ret, HTTP_CODE_INTERNAL_SERVER_ERROR);
}

/**
 * Functions Tested: _cmsg_proxy_service_info_add()
 *                   _cmsg_proxy_service_info_conflicts()
 *
 * Tests that input service_info are are not rejected if no conflicts occur.
 */
void
test_cmsg_proxy_service_info_add__no_conflicts (void)
{
    cmsg_service_info test_service_info_1 = {
        .url_string = "/api/v1/TEST/a",
        .http_verb = CMSG_HTTP_GET
    };

    cmsg_service_info test_service_info_2 = {
        .url_string = "/api/v1/TEST/b",
        .http_verb = CMSG_HTTP_GET
    };

    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));

    NP_ASSERT_TRUE (_cmsg_proxy_service_info_add (&test_service_info_1));
    NP_ASSERT_TRUE (_cmsg_proxy_service_info_add (&test_service_info_2));
}

/**
 * Functions Tested: _cmsg_proxy_service_info_add()
 *                   _cmsg_proxy_service_info_conflicts()
 *
 * Tests that input service_info that has a URL parameter is rejected
 * when that parameter conflicts with an existing node in the tree.
 */
void
test_cmsg_proxy_service_info_add__conflict_existing_non_param (void)
{
    cmsg_service_info test_service_info_1 = {
        .url_string = "/api/v1/TEST/a",
        .http_verb = CMSG_HTTP_GET
    };

    cmsg_service_info test_service_info_2 = {
        .url_string = "/api/v1/TEST/{b}",
        .http_verb = CMSG_HTTP_GET
    };

    np_syslog_ignore (".*");

    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));

    NP_ASSERT_TRUE (_cmsg_proxy_service_info_add (&test_service_info_1));
    NP_ASSERT_FALSE (_cmsg_proxy_service_info_add (&test_service_info_2));
}

/**
 * Functions Tested: _cmsg_proxy_service_info_add()
 *                   _cmsg_proxy_service_info_conflicts()
 *
 * Tests that input service_info that has a URL parameter is rejected
 * when that parameter conflicts with an existing node in the tree.
 */
void
test_cmsg_proxy_service_info_add__conflict_existing_non_param2 (void)
{
    cmsg_service_info test_service_info_1 = {
        .url_string = "/api/v1/TEST/a/{aa}",
        .http_verb = CMSG_HTTP_GET
    };

    cmsg_service_info test_service_info_2 = {
        .url_string = "/api/v1/{b}/1/2/3",
        .http_verb = CMSG_HTTP_GET
    };

    np_syslog_ignore (".*");

    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));

    NP_ASSERT_TRUE (_cmsg_proxy_service_info_add (&test_service_info_1));
    NP_ASSERT_FALSE (_cmsg_proxy_service_info_add (&test_service_info_2));
}

/**
 * Functions Tested: _cmsg_proxy_service_info_add()
 *                   _cmsg_proxy_service_info_conflicts()
 *
 * Tests that input service_info that has no URL parameter is rejected
 * when that parameter conflicts with an existing node in the tree that
 * has a URL parameter.
 */
void
test_cmsg_proxy_service_info_add__conflict_existing_param (void)
{
    cmsg_service_info test_service_info_1 = {
        .url_string = "/api/v1/TEST/{a}",
        .http_verb = CMSG_HTTP_GET
    };

    cmsg_service_info test_service_info_2 = {
        .url_string = "/api/v1/TEST/b",
        .http_verb = CMSG_HTTP_GET
    };

    np_syslog_ignore (".*");

    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));

    NP_ASSERT_TRUE (_cmsg_proxy_service_info_add (&test_service_info_1));
    NP_ASSERT_FALSE (_cmsg_proxy_service_info_add (&test_service_info_2));
}

/**
 * Functions Tested: _cmsg_proxy_service_info_add()
 *                   _cmsg_proxy_service_info_conflicts()
 *
 * Tests that input service_info that has no URL parameter is rejected
 * when that parameter conflicts with an existing node in the tree that
 * has a URL parameter.
 */
void
test_cmsg_proxy_service_info_add__conflict_existing_param2 (void)
{
    cmsg_service_info test_service_info_1 = {
        .url_string = "/api/v1/{aa}/a/{bb}",
        .http_verb = CMSG_HTTP_GET
    };

    cmsg_service_info test_service_info_2 = {
        .url_string = "/api/v1/TEST/1/2/3",
        .http_verb = CMSG_HTTP_GET
    };

    np_syslog_ignore (".*");

    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));

    NP_ASSERT_TRUE (_cmsg_proxy_service_info_add (&test_service_info_1));
    NP_ASSERT_FALSE (_cmsg_proxy_service_info_add (&test_service_info_2));
}

/**
 * Functions Tested: _cmsg_proxy_service_info_add()
 *                   _cmsg_proxy_service_info_conflicts()
 *
 * Tests that input service_info that has a URL parameter is rejected
 * when that parameter conflicts with an existing node in the tree that also
 * has a URL parameter.
 */
void
test_cmsg_proxy_service_info_add__conflict_param_with_existing_param (void)
{
    cmsg_service_info test_service_info_1 = {
        .url_string = "/api/v1/TEST/{a}",
        .http_verb = CMSG_HTTP_GET
    };

    cmsg_service_info test_service_info_2 = {
        .url_string = "/api/v1/TEST/{b}",
        .http_verb = CMSG_HTTP_GET
    };

    np_syslog_ignore (".*");

    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));

    NP_ASSERT_TRUE (_cmsg_proxy_service_info_add (&test_service_info_1));
    NP_ASSERT_FALSE (_cmsg_proxy_service_info_add (&test_service_info_2));
}

/**
 * Functions Tested: _cmsg_proxy_service_info_add()
 *                   _cmsg_proxy_service_info_conflicts()
 *
 * Tests that input service_info that has a URL parameter is rejected
 * when that parameter conflicts with an existing node in the tree that also
 * has a URL parameter.
 */
void
test_cmsg_proxy_service_info_add__conflict_param_with_existing_param2 (void)
{
    cmsg_service_info test_service_info_1 = {
        .url_string = "/api/v1/{aa}/a/{bb}",
        .http_verb = CMSG_HTTP_GET
    };

    cmsg_service_info test_service_info_2 = {
        .url_string = "/api/v1/{TEST}/1/2/3",
        .http_verb = CMSG_HTTP_GET
    };

    np_syslog_ignore (".*");

    proxy_entries_tree = g_node_new (g_strdup ("CMSG_API"));

    NP_ASSERT_TRUE (_cmsg_proxy_service_info_add (&test_service_info_1));
    NP_ASSERT_FALSE (_cmsg_proxy_service_info_add (&test_service_info_2));
}

/**
 * Function Tested: _cmsg_proxy_field_is_hidden()
 */
void
test_cmsg_proxy_field_is_hidden (void)
{
    NP_ASSERT_TRUE (_cmsg_proxy_field_is_hidden ("_hidden_field"));
    NP_ASSERT_FALSE (_cmsg_proxy_field_is_hidden ("non_hidden_field"));
}

/**
 * Function Tested: _cmsg_proxy_json_value_to_object()
 *
 * Test that a non-valid boolean value does not get converted to
 * a json object.
 */
void
test_cmsg_proxy_json_value_to_object__invalid_boolean (void)
{
    json_t *output_json = NULL;
    ProtobufCFieldDescriptor field_descriptor = { };

    field_descriptor.type = PROTOBUF_C_TYPE_BOOL;
    field_descriptor.label = PROTOBUF_C_LABEL_OPTIONAL;
    field_descriptor.name = "test";

    output_json = _cmsg_proxy_json_value_to_object (&field_descriptor, "blah");

    NP_ASSERT_NULL (output_json);
}
