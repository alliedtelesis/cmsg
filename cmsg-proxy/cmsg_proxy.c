/*
 * Copyright 2016, Allied Telesis Labs New Zealand, Ltd
 *
 * The CMSG proxy is a library that can be used by a web server to proxy HTTP
 * requests into CMSG service APIs.
 *
 * The required information is auto-generated by protoc-cmsg using the HttpRules
 * defined for each rpc in the CMSG .proto files. The user of the library only
 * needs to call two functions:
 *
 * - cmsg_proxy_init() to initialise the library
 * - cmsg_proxy() for each HTTP request the user wishes to proxy through to the
 *   CMSG service APIs
 */

#include <config.h>
#include "cmsg_proxy.h"
#include <glib.h>
#include <string.h>
#include <protobuf2json.h>
#include <cmsg/cmsg_client.h>
#include <dlfcn.h>
#include <dirent.h>
#include "cmsg_proxy_mem.h"
#include <ipc/common_types_auto.h>
#include <utility/sys.h>
#ifdef HAVE_COUNTERD
#include "cntrd_app_defines.h"
#include "cntrd_app_api.h"
#endif /* HAVE_COUNTERD */

#define MSG_BUF_LEN 200
#define CMSG_PROXY_LIB_PATH "/var/packages/network/lib"

/* Standard HTTP/1.1 status codes */
#define HTTP_CODE_CONTINUE                  100 /* Continue with request, only partial content transmitted */
#define HTTP_CODE_SWITCHING                 101 /* Switching protocols */
#define HTTP_CODE_OK                        200 /* The request completed successfully */
#define HTTP_CODE_CREATED                   201 /* The request has completed and a new resource was created */
#define HTTP_CODE_ACCEPTED                  202 /* The request has been accepted and processing is continuing */
#define HTTP_CODE_NOT_AUTHORITATIVE         203 /* The request has completed but content may be from another source */
#define HTTP_CODE_NO_CONTENT                204 /* The request has completed and there is no response to send */
#define HTTP_CODE_RESET                     205 /* The request has completed with no content. Client must reset view */
#define HTTP_CODE_PARTIAL                   206 /* The request has completed and is returning partial content */
#define HTTP_CODE_MOVED_PERMANENTLY         301 /* The requested URI has moved permanently to a new location */
#define HTTP_CODE_MOVED_TEMPORARILY         302 /* The URI has moved temporarily to a new location */
#define HTTP_CODE_SEE_OTHER                 303 /* The requested URI can be found at another URI location */
#define HTTP_CODE_NOT_MODIFIED              304 /* The requested resource has changed since the last request */
#define HTTP_CODE_USE_PROXY                 305 /* The requested resource must be accessed via the location proxy */
#define HTTP_CODE_TEMPORARY_REDIRECT        307 /* The request should be repeated at another URI location */
#define HTTP_CODE_BAD_REQUEST               400 /* The request is malformed */
#define HTTP_CODE_UNAUTHORIZED              401 /* Authentication for the request has failed */
#define HTTP_CODE_PAYMENT_REQUIRED          402 /* Reserved for future use */
#define HTTP_CODE_FORBIDDEN                 403 /* The request was legal, but the server refuses to process */
#define HTTP_CODE_NOT_FOUND                 404 /* The requested resource was not found */
#define HTTP_CODE_BAD_METHOD                405 /* The request HTTP method was not supported by the resource */
#define HTTP_CODE_NOT_ACCEPTABLE            406 /* The requested resource cannot generate the required content */
#define HTTP_CODE_REQUEST_TIMEOUT           408 /* The server timed out waiting for the request to complete */
#define HTTP_CODE_CONFLICT                  409 /* The request had a conflict in the request headers and URI */
#define HTTP_CODE_GONE                      410 /* The requested resource is no longer available */
#define HTTP_CODE_LENGTH_REQUIRED           411 /* The request did not specify a required content length */
#define HTTP_CODE_PRECOND_FAILED            412 /* The server cannot satisfy one of the request preconditions */
#define HTTP_CODE_REQUEST_TOO_LARGE         413 /* The request is too large for the server to process */
#define HTTP_CODE_REQUEST_URL_TOO_LARGE     414 /* The request URI is too long for the server to process */
#define HTTP_CODE_UNSUPPORTED_MEDIA_TYPE    415 /* The request media type is not supported by the server or resource */
#define HTTP_CODE_RANGE_NOT_SATISFIABLE     416 /* The request content range does not exist for the resource */
#define HTTP_CODE_EXPECTATION_FAILED        417 /* The server cannot satisfy the Expect header requirements */
#define HTTP_CODE_NO_RESPONSE               444 /* The connection was closed with no response to the client */
#define HTTP_CODE_INTERNAL_SERVER_ERROR     500 /* Server processing or configuration error. No response generated */
#define HTTP_CODE_NOT_IMPLEMENTED           501 /* The server does not recognize the request or method */
#define HTTP_CODE_BAD_GATEWAY               502 /* The server cannot act as a gateway for the given request */
#define HTTP_CODE_SERVICE_UNAVAILABLE       503 /* The server is currently unavailable or overloaded */
#define HTTP_CODE_GATEWAY_TIMEOUT           504 /* The server gateway timed out waiting for the upstream server */
#define HTTP_CODE_BAD_VERSION               505 /* The server does not support the HTTP protocol version */
#define HTTP_CODE_INSUFFICIENT_STORAGE      507 /* The server has insufficient storage to complete the request */

/**
 * Map the ANT code returned from the CMSG API call to the
 * HTTP response code sent in the HTTP header.
 */
int ant_code_to_http_code_array[] = {
    HTTP_CODE_OK,                       /* ANT_CODE_OK */
    HTTP_CODE_REQUEST_TIMEOUT,          /* ANT_CODE_CANCELLED */
    HTTP_CODE_INTERNAL_SERVER_ERROR,    /* ANT_CODE_UNKNOWN */
    HTTP_CODE_BAD_REQUEST,              /* ANT_CODE_INVALID_ARGUMENT */
    HTTP_CODE_REQUEST_TIMEOUT,          /* ANT_CODE_DEADLINE_EXCEEDED */
    HTTP_CODE_NOT_FOUND,                /* ANT_CODE_NOT_FOUND */
    HTTP_CODE_CONFLICT,                 /* ANT_CODE_ALREADY_EXISTS */
    HTTP_CODE_FORBIDDEN,                /* ANT_CODE_PERMISSION_DENIED */
    HTTP_CODE_FORBIDDEN,                /* ANT_CODE_RESOURCE_EHAUSTED */
    HTTP_CODE_BAD_REQUEST,              /* ANT_CODE_FAILED_PRECONDITION */
    HTTP_CODE_CONFLICT,                 /* ANT_CODE_ABORTED */
    HTTP_CODE_BAD_REQUEST,              /* ANT_CODE_OUT_OF_RANGE */
    HTTP_CODE_NOT_IMPLEMENTED,          /* ANT_CODE_UNIMPLEMENTED */
    HTTP_CODE_INTERNAL_SERVER_ERROR,    /* ANT_CODE_INTERNAL */
    HTTP_CODE_SERVICE_UNAVAILABLE,      /* ANT_CODE_UNAVAILABLE */
    HTTP_CODE_INTERNAL_SERVER_ERROR,    /* ANT_CODE_DATALOSS */
    HTTP_CODE_UNAUTHORIZED,             /* ANT_CODE_UNAUTHENTICATED */
};

ARRAY_SIZE_COMPILE_CHECK (ant_code_to_http_code_array, ANT_CODE_MAX);

typedef cmsg_service_info *(*proxy_defs_array_get_func_ptr) ();
typedef int (*proxy_defs_array_size_func_ptr) ();

typedef struct
{
    char *key;
    char *value;
} cmsg_url_parameter;

/* Current CMSG API version string */
#define CMSG_API_VERSION_STR                "CMSG-API"

static GList *library_handles_list = NULL;
static GList *proxy_clients_list = NULL;
static GNode *proxy_entries_tree = NULL;

#ifdef HAVE_COUNTERD
/* Global counters */
typedef struct _counter_info
{
    /* Counter session */
    void *cntr_session;

    /* Counters */
    void *cntr_unknown_service;
    void *cntr_service_info_loaded;
    void *cntr_service_info_unloaded;
    void *cntr_client_create_failure;
    void *cntr_client_created;
    void *cntr_client_freed;
} counter_info;

/* Per-service counters */
typedef struct _session_counter_info
{
    /* Counter session */
    void *cntr_session;

    /* Counters */
    void *cntr_api_calls;
    void *cntr_error_missing_client;
    void *cntr_error_malformed_input;
    void *cntr_error_api_failure;
    void *cntr_error_missing_error_info;
    void *cntr_error_protobuf_to_json;
} session_counter_info;

/* Global counters */
static counter_info proxy_counter;
/* Table to store per-session counters */
static GHashTable *proxy_session_counter_table = NULL;

static session_counter_info *_proxy_session_counter_info_new (const char *service_name);
static void _proxy_session_counter_info_delete (session_counter_info *session_counter);
static void _proxy_session_counter_init (const cmsg_service_info *service_info);
static void _proxy_session_counter_deinit_all (void);

#define CMSG_PROXY_COUNTER_REGISTER(info,str,cntr) \
    cntrd_app_register_ctr_in_group ((info)->cntr_session, (str), &(info)->cntr)

#define SESSION_KEY(service)    (service->service_descriptor)

/* Increment global counter */
#define CMSG_PROXY_COUNTER_INC(counter)     \
    cntrd_app_inc_ctr (proxy_counter.cntr_session, proxy_counter.counter)

/* Increment session counter */
#define CMSG_PROXY_SESSION_COUNTER_INC(service,counter)             \
    do {                                                            \
        session_counter_info *_sc;                                  \
        _sc = g_hash_table_lookup (proxy_session_counter_table,     \
                                   SESSION_KEY ((service)));        \
        if (_sc)                                                    \
        {                                                           \
            cntrd_app_inc_ctr (_sc->cntr_session, _sc->counter);    \
        }                                                           \
    } while (0)
#else
#define CMSG_PROXY_COUNTER_INC(counter)
#define CMSG_PROXY_SESSION_COUNTER_INC(service,counter)
#endif /* HAVE_COUNTERD */

/**
 * SET CMSG API info details to the proxy tree
 *
 * @param leaf_node - Add the CMSG service info to this leaf node
 * @param service_info - CMSG service info to be added
 */
static void
_cmsg_proxy_api_info_node_set (GNode *leaf_node, const cmsg_service_info *service_info)
{
    cmsg_proxy_api_info *api_info = leaf_node->data;

    switch (service_info->http_verb)
    {
    case CMSG_HTTP_GET:
        api_info->cmsg_http_get = service_info;
        break;
    case CMSG_HTTP_PUT:
        api_info->cmsg_http_put = service_info;
        break;
    case CMSG_HTTP_POST:
        api_info->cmsg_http_post = service_info;
        break;
    case CMSG_HTTP_DELETE:
        api_info->cmsg_http_delete = service_info;
        break;
    case CMSG_HTTP_PATCH:
        api_info->cmsg_http_patch = service_info;
        break;
    default:
        break;
    }
}

/**
 * Get CMSG proxy API info node from the last node of a URL. If the API
 * info node doesn't exist create one otherwise return the existing
 * one. If the last node corresponding to a URL is the leaf node, then
 * we need to create one. If the last node is not a leaf node, check
 * its first child. If the first child is not a leaf node, create
 * cmsg_api_info_node. cmsg_api_info_node is always inserted as the
 * first child.
 * eg: url_string1 = "/v1/A/B/C"
 *     url_string2 = "/v1/A/B/C/D"
 *     url_string3 = "/v1/A/B"
 *     url_string4 = "/v1/A/B/C/E"
 *     url_string5 = "/v1/A/B/C/F"
 *     url_string6 = "/v1/A/B/C/G"
 *     url_string7 = "/v1/A/B/C/G/H"
 *
 *           --------
 *          |CMSG-API|   <====Root Node
 *           --------
 *              |
 *              |
 *            ------
 *           |  v1  | <=== Level 1
 *            ------
 *              |
 *              |
 *            -----
 *           |  A  |  <=== Level 2
 *            -----
 *              |
 *              |
 *            -----
 *           |  B  |  <=== Level 3
 *            -----
 *           /    \
 *          /      \
 *     --------   -----
 *    |API INFO| |  C  |--------------------------------------- <=== Level 3
 *     --------   -----               |            |          |
 *               /     \              |            |          |
 *              /       \             |            |          |
 *         --------     -----        -----       -----      -----
 *        |API INFO|   |  D  |      |  E  |     |  F  |    |  G  |------ <=== Level 4
 *         --------     -----        -----       -----      -----       |
 *                        |            |           |          |         |
 *                     --------     --------    --------   --------   -----
 *                    |API INFO|   |API INFO|  |API INFO| |API INFO| |  H  | <=== Level 5
 *                     --------     --------    --------   --------   -----
 *                                                                      |
 *                                                                   --------
 *                                                                  |API INFO|
 *                                                                   --------
 *
 *  Important Note: API INFO is added as the first child for a URL.
 *
 *  @param last_node Last GNode corresponding to a URL
 *  @return  Newly created cmsg_api_info_node or the existing one if found.
 */
static GNode *
_cmsg_proxy_api_info_node_new (GNode *last_node)
{
    GNode *first_child = NULL;
    GNode *cmsg_api_info_node = NULL;
    cmsg_proxy_api_info *cmsg_proxy_api_ptr;

    /* Insert cmsg_api_info_node as the first child of the last_node. */
    if (G_NODE_IS_LEAF (last_node))
    {
        cmsg_proxy_api_ptr = CMSG_PROXY_CALLOC (1, sizeof (*cmsg_proxy_api_ptr));
        cmsg_api_info_node = g_node_insert_data (last_node, 0, cmsg_proxy_api_ptr);
    }
    else
    {
        first_child = g_node_first_child (last_node);
        /* Check whether the first child is API info node. Otherwise create one and
         * insert as the first child.*/
        if (G_NODE_IS_LEAF (first_child))
        {
            cmsg_api_info_node = first_child;
        }
        else
        {
            cmsg_proxy_api_ptr = CMSG_PROXY_CALLOC (1, sizeof (*cmsg_proxy_api_ptr));
            cmsg_api_info_node = g_node_insert_data (last_node, 0, cmsg_proxy_api_ptr);
        }
    }

    return cmsg_api_info_node;
}

/**
 * Free CMSG API info data allocated to the leaf nodes
 *
 * @param leaf_node - leaf node contains CMSG API info
 * @param data - Unused data to the callback
 *
 * @return - returns TRUE if the received leaf node is NULL otherwise FALSE
 * The callback should return FALSE to continue the traversal.
 */
static gboolean
_cmsg_proxy_api_info_free (GNode *leaf_node, gpointer data)
{
    cmsg_proxy_api_info *api_info;

    if (leaf_node == NULL)
    {
        return TRUE;
    }

    api_info = leaf_node->data;
    CMSG_PROXY_FREE (api_info);

    CMSG_PROXY_COUNTER_INC (cntr_service_info_unloaded);

    return FALSE;
}

/**
 * Free each node data allocated to the non leaf nodes
 *
 * @param node - node contains allocated string data
 * @param data - Unused data to the callback
 *
 * @return - returns TRUE if the received leaf node is NULL otherwise FALSE
 * The callback should return FALSE to continue the traversal.
 */
static gboolean
_cmsg_proxy_entry_data_free (GNode *node, gpointer data)
{
    char *str;

    if (node == NULL)
    {
        return TRUE;
    }

    str = node->data;
    CMSG_PROXY_FREE (str);

    return FALSE;
}

/**
 * Parse the given URL string and add to proxy_entries_tree.
 * Add 'cmsg_service_info' to the leaf node.
 * The parser believes the received 'url' is in the correct format.
 * eg: url_string = "/v5_4_7/statistics/interfaces/enabled"
 *     url_string = "/v5_4_8/statistics/interfaces/enabled"
 *     url_string = "/v5_4_8/statistics/interfaces/<name>/history"
 *     url_string = "/v5_4_8/statistics/interfaces/<name>/current"
 *     url_string = "/v5_4_8/statistics/interfaces"
 *
 *             --------
 *            |CMSG-API|   <====Root Node
 *             --------
 *            /        \
 *           /          \
 *       ------        ------
 *      |v5_4_7|      |v5_4_8|  <==== First children
 *       ------        ------
 *         |             |
 *         |             |
 *     ----------      ----------
 *    |statistics|    |statistics|
 *     ----------      ----------
 *         |              |
 *         |              |
 *     ----------      ----------
 *    |interfaces|    |interfaces|----------
 *     ----------      ----------           |
 *      |               /      \            |
 *      |              /        \           |
 *   -------        --------    ------     ------
 *  |enabled|      |API INFO|  |enabled|  |<name>| <=== Parameter "<name>" is stored in the tree
 *   -------        --------    ------     ------
 *       |                       |         /   \
 *       |                       |        /     \
 *   --------                ---------   /       \
 *  |API INFO|              |API INFO | |         |
 *   --------                ---------  |         |
 *                                   -------  -------
 *                                  |history| |current|
 *                                   -------   -------
 *                                     |          |
 *                                     |          |
 *                                  --------   ---------
 *                                 |API INFO| |API INFO |
 *                                  --------   ---------
 * API INFO at the leaf node points to the corresponding cmsg_service_info
 *
 * @param service_info CMSG service information
 */
static gboolean
_cmsg_proxy_service_info_add (const cmsg_service_info *service_info)
{
    char *tmp_url = NULL;
    char *next_entry = NULL;
    char *rest = NULL;
    GNode *parent_node = g_node_get_root (proxy_entries_tree);
    GNode *node = NULL;
    GNode *cmsg_api_info_node = NULL;
    gboolean found;

    tmp_url = CMSG_PROXY_STRDUP (service_info->url_string);

    for (next_entry = strtok_r (tmp_url, "/", &rest); next_entry;
         next_entry = strtok_r (NULL, "/", &rest))
    {
        found = FALSE;

        /* Check whether the node already exists in the tree. */
        node = g_node_first_child (parent_node);

        while (node)
        {
            /* API info node should be skipped */
            if (!G_NODE_IS_LEAF (node) && strcmp (node->data, next_entry) == 0)
            {
                found = TRUE;
                break;
            }
            node = g_node_next_sibling (node);
        }

        /* Add if it doesn't exist. Insert as the last child of parent_node. */
        if (found == FALSE)
        {
            node = g_node_insert_data (parent_node, -1, CMSG_PROXY_STRDUP (next_entry));
        }

        parent_node = node;
    }

    cmsg_api_info_node = _cmsg_proxy_api_info_node_new (parent_node);

    /* Fill the cmsg_service_info to the leaf node */
    _cmsg_proxy_api_info_node_set (cmsg_api_info_node, service_info);

    CMSG_PROXY_FREE (tmp_url);

    return TRUE;
}

/**
 * Initialise the cmsg proxy list with the autogenerated array entries
 *
 * @param array - Pointer to the start of the array of entries
 * @param length - Length of the array
 */
static void
_cmsg_proxy_service_info_init (cmsg_service_info *array, int length)
{
    int i = 0;
    const cmsg_service_info *service_info;

    for (i = 0; i < length; i++)
    {
        service_info = &array[i];

        if (_cmsg_proxy_service_info_add (service_info))
        {
            CMSG_PROXY_COUNTER_INC (cntr_service_info_loaded);
        }

#ifdef HAVE_COUNTERD
        /* Initialise service counter */
        _proxy_session_counter_init (service_info);
#endif
    }
}

/**
 * Deinitialise the cmsg proxy entry tree with the autogenerated array entries
 */
static void
_cmsg_proxy_service_info_deinit (void)
{
    GNode *root = g_node_get_root (proxy_entries_tree);

    /* Free cmsg service API info if proxy_entries_tree is not empty. */
    if (!G_NODE_IS_LEAF (root))
    {
        g_node_traverse (root, G_LEVEL_ORDER, G_TRAVERSE_LEAVES, -1,
                         _cmsg_proxy_api_info_free, NULL);

        /* Now free all nodes' data */
        g_node_traverse (root, G_POST_ORDER, G_TRAVERSE_NON_LEAVES, -1,
                         _cmsg_proxy_entry_data_free, NULL);
    }
    else
    {
        /* Free the root node's data. */
        _cmsg_proxy_entry_data_free (root, NULL);
    }

    g_node_destroy (proxy_entries_tree);
    proxy_entries_tree = NULL;
}

/**
 * Helper function used by _cmsg_proxy_find_client_by_service()
 * with g_list_find_custom() to find an entry from the proxy
 * client list based on service name.
 *
 * @param list_data - GList data passed in by g_list_find_custom()
 * @param service_name - Service name to match
 */
static int
_cmsg_proxy_service_name_cmp (void *list_data, void *service_name)
{
    cmsg_client *list_client = (cmsg_client *) list_data;

    return strcmp (list_client->descriptor->name, service_name);
}

/**
 * Lookup a CMSG client from the proxy_clients_list based on service_descriptor
 *
 * @param service_descriptor - CMSG service descriptor to use for the lookup
 *
 * @return - Pointer to the CMSG client if found, NULL otherwise.
 */
static cmsg_client *
_cmsg_proxy_find_client_by_service (const ProtobufCServiceDescriptor *service_descriptor)
{
    GList *found_data;

    found_data = g_list_find_custom (proxy_clients_list, service_descriptor->name,
                                     (GCompareFunc) _cmsg_proxy_service_name_cmp);
    if (found_data)
    {
        return found_data->data;
    }

    return NULL;
}

/**
 * Create a CMSG client to connect to the input service descriptor and
 * add this client to the proxy clients list.
 *
 * @param service_descriptor - CMSG service descriptor to connect the client to
 */
static void
_cmsg_proxy_create_client (const ProtobufCServiceDescriptor *service_descriptor)
{
    cmsg_client *client = NULL;

    client = cmsg_create_client_unix (service_descriptor);
    if (!client)
    {
        syslog (LOG_ERR, "Failed to create client for service: %s",
                service_descriptor->name);
        CMSG_PROXY_COUNTER_INC (cntr_client_create_failure);
        return;
    }

    CMSG_PROXY_COUNTER_INC (cntr_client_created);

    proxy_clients_list = g_list_append (proxy_clients_list, (void *) client);
    return;
}

/**
 * Free the CMSG proxy clients created
 */
static void
_cmsg_proxy_client_free (gpointer data, gpointer user_data)
{
    cmsg_client *client = (cmsg_client *) data;

    cmsg_destroy_client_and_transport (client);

    CMSG_PROXY_COUNTER_INC (cntr_client_freed);
}

/**
 * Find CMSG service info corresponding to the given cmsg_http_verb from cmsg_proxy_api_info
 *
 * @param api_info - CMSG API info
 * @param verb - HTTP action verb
 *
 * @return Returns matching cmsg_service_info from api_info if not NULL
 */
static const cmsg_service_info *
cmsg_proxy_service_info_get (const cmsg_proxy_api_info *api_info, cmsg_http_verb verb)
{
    switch (verb)
    {
    case CMSG_HTTP_GET:
        return api_info->cmsg_http_get;
    case CMSG_HTTP_PUT:
        return api_info->cmsg_http_put;
    case CMSG_HTTP_POST:
        return api_info->cmsg_http_post;
    case CMSG_HTTP_DELETE:
        return api_info->cmsg_http_delete;
    case CMSG_HTTP_PATCH:
        return api_info->cmsg_http_patch;
    default:
        return NULL;
    }
}

/**
 * Callback to add CMSG clients.
 *
 * @param leaf_node - leaf node that contains cmsg_proxy_api_info
 * @param data - data passed in by the caller. This is NULL
 *
 * @returns FALSE if the traverse need to be continued otherwise TRUE
 */
static gboolean
_cmsg_proxy_clients_add (GNode *leaf_node, gpointer data)
{
    cmsg_proxy_api_info *api_info;
    const cmsg_service_info *service_info;
    int action;

    if (leaf_node == NULL)
    {
        return TRUE;
    }
    api_info = leaf_node->data;

    for (action = CMSG_HTTP_GET; action <= CMSG_HTTP_PATCH; action++)
    {
        service_info = cmsg_proxy_service_info_get (api_info, action);
        if (service_info &&
            !_cmsg_proxy_find_client_by_service (service_info->service_descriptor))
        {
            _cmsg_proxy_create_client (service_info->service_descriptor);
        }
    }

    return FALSE;
}

/**
 * Initialise the CMSG clients required to connect to every service descriptor
 * used in the CMSG proxy entries tree. Traverse all the leaf nodes in the
 * GNode proxy entry tree. All the leaf nodes should be contain cmsg_proxy_api_info.
 */
static void
_cmsg_proxy_clients_init (void)
{
    GNode *root = g_node_get_root (proxy_entries_tree);

    /* Do not traverse if proxy_entries_tree is empty. */
    if (!G_NODE_IS_LEAF (root))
    {
        g_node_traverse (root, G_LEVEL_ORDER, G_TRAVERSE_LEAVES, -1,
                         _cmsg_proxy_clients_add, NULL);
    }
}

/**
 * Deinitialise the CMSG clients.
 */
static void
_cmsg_proxy_clients_deinit (void)
{
    g_list_foreach (proxy_clients_list, _cmsg_proxy_client_free, NULL);
    g_list_free (proxy_clients_list);
    proxy_clients_list = NULL;
}

/**
 * Helper function for _cmsg_proxy_library_handles_deinit().
 * Call dlclose in a way that compiles with g_list_free_full.
 */
static void
_cmsg_proxy_dlclose (gpointer data)
{
    dlclose (data);
}

/**
 * Close the loaded library handles.
 */
static void
_cmsg_proxy_library_handles_close (void)
{
    g_list_free_full (library_handles_list, _cmsg_proxy_dlclose);
    library_handles_list = NULL;
}

/**
 * Loads all of the *_proto_proxy_def.so libraries that exist in
 * CMSG_PROXY_LIB_PATH into the cmsg proxy library.
 */
static void
_cmsg_proxy_library_handles_load (void)
{
    DIR *d = NULL;
    struct dirent *dir = NULL;
    void *lib_handle = NULL;
    proxy_defs_array_get_func_ptr get_func_addr = NULL;
    proxy_defs_array_size_func_ptr size_func_addr = NULL;
    char *library_path = NULL;

    d = opendir (CMSG_PROXY_LIB_PATH);
    if (d == NULL)
    {
        syslog (LOG_ERR, "Directory '%s' could not be opened\n", CMSG_PROXY_LIB_PATH);
        return;
    }

    while ((dir = readdir (d)) != NULL)
    {
        /* Check that dir points to a file, not (sym)link or directory */
        if (dir->d_type == DT_REG && strstr (dir->d_name, "proto_proxy_def.so"))
        {
            if (asprintf (&library_path, "%s/%s", CMSG_PROXY_LIB_PATH, dir->d_name) < 0)
            {
                syslog (LOG_ERR, "Unable able to load library %s", dir->d_name);
                continue;
            }

            lib_handle = dlopen (library_path, RTLD_NOW | RTLD_GLOBAL);
            if (lib_handle)
            {
                get_func_addr = dlsym (lib_handle, "cmsg_proxy_array_get");
                size_func_addr = dlsym (lib_handle, "cmsg_proxy_array_size");

                if (get_func_addr && size_func_addr)
                {
                    _cmsg_proxy_service_info_init (get_func_addr (), size_func_addr ());

                    /* We need to leave the library loaded in the process address space so
                     * that the data can be accessed. Store a pointer to the library handle
                     * so that it can be closed at deinit. */
                    library_handles_list = g_list_prepend (library_handles_list,
                                                           lib_handle);
                }
                else
                {
                    dlclose (lib_handle);
                }
            }
            free (library_path);
        }
    }

    closedir (d);
}


/**
 * Create a new json object from the given json string
 *
 * @param json_object - Place holder for the created json object
 * @param input_json  - input json string to create the json object
 * @param error       - Place holder for error occurred in the creation
 *
 */
static void
_cmsg_proxy_json_object_create (json_t **json_object, const char *input_json,
                                json_error_t *error)
{
    *json_object = json_loads (input_json, 0, error);
}

/**
 *
 * Destroy the given json object
 *
 * @param json_object - json object to be destroyed
 */
static void
_cmsg_proxy_json_object_destroy (json_t *json_object)
{
    if (json_object)
    {
        json_decref (json_object);
    }
}

/**
 * Allocate memory and store values for an embedded url parameter
 *
 * @param key - The name of the url parameter ie 'id' for /vlan/vlans/{id}
 * @param value - The parameter ie '5' for /vlan/vlans/5/...
 * @return - allocated cmsg_url_parameter or NULL if allocation fails
 */
static cmsg_url_parameter *
_cmsg_proxy_create_url_parameter (const char *key, const char *value)
{
    cmsg_url_parameter *new = calloc (1, sizeof (cmsg_url_parameter));

    if (new)
    {
        /* strip the braces from the parameter name */
        new->key = strndup (key + 1, strlen (key) - 2);
        new->value = value ? strdup (value) : NULL;
    }
    return new;
}

/**
 * Free a cmsg_url_parameter structure
 * @param ptr - the cms_url_parameter to be freed
 */
static void
_cmsg_proxy_free_url_parameter (gpointer ptr)
{
    cmsg_url_parameter *p = (cmsg_url_parameter *) ptr;

    if (p)
    {
        free (p->key);
        free (p->value);
        free (p);
    }
}

/**
 * Lookup a cmsg_service_info entry from the proxy tree based on URL and
 * HTTP verb and update jason_object if any parameter found in the URL
 *
 * @param url - URL string to use for the lookup.
 * @param http_verb - HTTP verb to use for the lookup.
 * @param json_object - jason object to update
 *
 * @return - Pointer to the cmsg_service_info entry if found, NULL otherwise.
 */
static const cmsg_service_info *
_cmsg_proxy_find_service_from_url_and_verb (const char *url, cmsg_http_verb verb,
                                            GList **url_parameters)
{
    GNode *node;
    char *tmp_url;
    char *next_entry = NULL;
    char *rest = NULL;
    const char *key = NULL;
    GNode *parent_node;
    GNode *info_node;
    int key_length;
    cmsg_url_parameter *param = NULL;

    tmp_url = CMSG_PROXY_STRDUP (url);
    parent_node = g_node_get_root (proxy_entries_tree);

    for (next_entry = strtok_r (tmp_url, "/", &rest); next_entry;
         next_entry = strtok_r (NULL, "/", &rest))
    {
        node = g_node_first_child (parent_node);
        while (node)
        {
            if (!G_NODE_IS_LEAF (node) && strcmp (next_entry, node->data) == 0)
            {
                parent_node = node;
                break;
            }
            else
            {
                key = (const char *) node->data;
                key_length = key ? strlen (key) : 0;

                /* if this URL segment is a parameter, store it to be parsed later */
                if (key && key_length && key[0] == '{' && key[key_length - 1] == '}')
                {

                    param = _cmsg_proxy_create_url_parameter (key, next_entry);
                    *url_parameters = g_list_prepend (*url_parameters, param);
                    parent_node = node;
                    break;
                }

            }
            node = g_node_next_sibling (node);
        }

        /* No match found. */
        if (node == NULL)
        {
            CMSG_PROXY_FREE (tmp_url);
            return NULL;
        }
    }

    CMSG_PROXY_FREE (tmp_url);

    info_node = g_node_first_child (parent_node);
    if ((info_node) != NULL && G_NODE_IS_LEAF (info_node))
    {
        return cmsg_proxy_service_info_get (info_node->data, verb);

    }

    return NULL;
}

/**
 * Convert parameters embedded in the URL into the correct format for the protobuf messages
 *
 * If the target protobuf is an integer type: attempt to convert the parameter. If the parameter
 * cannot be converted, leave as is. The protobuf2json library will raise an error. No sign or overflow
 * checking is yet performed.
 *
 * If the target field is repeated, the parameter will be stored as the first and only
 * element.
 *
 * @param parameters - list of parameter-name & parameter pairs
 * @param json_object - the message body
 * @param msg_descriptor - used to determine the target field type when converting to JSON
 */
void
_cmsg_proxy_parse_url_parameters (GList *parameters, json_t **json_object,
                                  const ProtobufCMessageDescriptor *msg_descriptor)
{
    GList *iter = NULL;
    const ProtobufCFieldDescriptor *field_descriptor = NULL;
    cmsg_url_parameter *p = NULL;
    json_t *new_object = NULL;
    char *fmt = NULL;
    char *endptr = NULL;
    long int lvalue;

    for (iter = parameters; iter; iter = g_list_next (iter))
    {
        p = (cmsg_url_parameter *) iter->data;

        if (!p || !p->key)
        {
            continue;
        }

        /* Find the target type */
        field_descriptor = protobuf_c_message_descriptor_get_field_by_name (msg_descriptor,
                                                                            p->key);

        if (!field_descriptor)
        {
            continue;   /* TODO: add to json as strings (for unexpected argument error) */
        }

        switch (field_descriptor->type)
        {
        case PROTOBUF_C_TYPE_INT32:
        case PROTOBUF_C_TYPE_SINT32:
        case PROTOBUF_C_TYPE_SFIXED32:
        case PROTOBUF_C_TYPE_UINT32:
        case PROTOBUF_C_TYPE_FIXED32:
            lvalue = strtol (p->value, &endptr, 0);
            if (endptr && *endptr == '\0')
            {
                fmt = field_descriptor->label == PROTOBUF_C_LABEL_REPEATED ?
                    "{s[i]}" : "{si}";
                new_object = json_pack (fmt, p->key, lvalue);
                break;
            }
            /* fall through (storing as string) */
        case PROTOBUF_C_TYPE_ENUM:
        case PROTOBUF_C_TYPE_STRING:
            fmt = field_descriptor->label == PROTOBUF_C_LABEL_REPEATED ?
                "{s[s?]}" : "{ss?}";

            new_object = json_pack (fmt, p->key, p->value);
            break;
            /* Not (currently) supported as URL parameters */
        case PROTOBUF_C_TYPE_UINT64:
        case PROTOBUF_C_TYPE_INT64:
        case PROTOBUF_C_TYPE_SINT64:
        case PROTOBUF_C_TYPE_SFIXED64:
        case PROTOBUF_C_TYPE_FIXED64:
        case PROTOBUF_C_TYPE_FLOAT:
        case PROTOBUF_C_TYPE_DOUBLE:
        case PROTOBUF_C_TYPE_BOOL:
        case PROTOBUF_C_TYPE_BYTES:
        case PROTOBUF_C_TYPE_MESSAGE:
        default:
            break;
        }

        if (!new_object)
        {
            continue;
        }

        if (*json_object)
        {
            json_object_update (*json_object, new_object);
            json_decref (new_object);
        }
        else
        {
            *json_object = new_object;
        }
    }
}

/**
 * Convert the input json string into a protobuf message structure.
 *
 * @param input_json - The json string to convert.
 * @param msg_descriptor - The message descriptor that defines the protobuf
 *                         message to convert the json string to.
 * @param output_protobuf - A pointer to store the output protobuf message.
 *                          If the conversion succeeds then this pointer must
 *                          be freed by the caller.
 *
 * @return - ANT_CODE_OK on success, relevant ANT code on failure.
 */
static ant_code
_cmsg_proxy_convert_json_to_protobuf (json_t *json_object,
                                      const ProtobufCMessageDescriptor *msg_descriptor,
                                      ProtobufCMessage **output_protobuf, char **message)
{
    char conversion_message[MSG_BUF_LEN] = { 0 };
    ant_code ret = ANT_CODE_OK;
    int res = json2protobuf_object (json_object, msg_descriptor, output_protobuf,
                                    conversion_message, MSG_BUF_LEN);

    /* Only report messages deemed user-friendly */
    switch (res)
    {
    case PROTOBUF2JSON_ERR_REQUIRED_IS_MISSING:
    case PROTOBUF2JSON_ERR_UNKNOWN_FIELD:
    case PROTOBUF2JSON_ERR_IS_NOT_OBJECT:
    case PROTOBUF2JSON_ERR_IS_NOT_ARRAY:
    case PROTOBUF2JSON_ERR_IS_NOT_INTEGER:
    case PROTOBUF2JSON_ERR_IS_NOT_INTEGER_OR_REAL:
    case PROTOBUF2JSON_ERR_IS_NOT_BOOLEAN:
    case PROTOBUF2JSON_ERR_IS_NOT_STRING:
    case PROTOBUF2JSON_ERR_UNKNOWN_ENUM_VALUE:
    case PROTOBUF2JSON_ERR_CANNOT_PARSE_STRING:
    case PROTOBUF2JSON_ERR_CANNOT_PARSE_FILE:
    case PROTOBUF2JSON_ERR_UNSUPPORTED_FIELD_TYPE:
        if (message)
        {
            *message = strdup (conversion_message);
        }
        ret = ANT_CODE_INVALID_ARGUMENT;
        break;
    case PROTOBUF2JSON_ERR_CANNOT_DUMP_STRING:
    case PROTOBUF2JSON_ERR_CANNOT_DUMP_FILE:
    case PROTOBUF2JSON_ERR_JANSSON_INTERNAL:
    case PROTOBUF2JSON_ERR_CANNOT_ALLOCATE_MEMORY:
        ret = ANT_CODE_INTERNAL;
    }

    return ret;
}

/**
 * Convert the input protobuf message into a json string.
 *
 * @param input_protobuf - The protobuf message to convert.
 * @param output_json - A pointer to store the output json string.
 *                      If the conversion succeeds then this pointer must
 *                      be freed by the caller.
 *
 * @return - true on success, false on failure.
 */
static bool
_cmsg_proxy_protobuf2json_string (ProtobufCMessage *input_protobuf, char **output_json)
{
    if (protobuf2json_string (input_protobuf, JSON_INDENT (4), output_json, NULL, 0) < 0)
    {
        return false;
    }

    return true;
}

/**
 * Convert the input protobuf message into a json object.
 *
 * @param input_protobuf - The protobuf message to convert.
 * @param output_json - A pointer to store the output json object.
 *                      If the conversion succeeds then this object must
 *                      be freed by the caller.
 *
 * @return - true on success, false on failure.
 */
static bool
_cmsg_proxy_protobuf2json_object (ProtobufCMessage *input_protobuf, json_t **output_json)
{
    if (protobuf2json_object (input_protobuf, output_json, NULL, 0) < 0)
    {
        return false;
    }

    return true;
}

/**
 * Helper function to call the CMSG api function pointer in the
 * cmsg service info entry. This is required as the api function
 * takes a different number of parameters depending on the input/
 * output message types.
 *
 * @param client - CMSG client to call the API with
 * @param input_msg - Input message to send with the API
 * @param output_msg - Pointer for the received message from the API
 *                     to be stored in.
 * @param service_info - Service info entry that contains the API
 *                       function to call.
 *
 * @returns - ANT_CODE_OK on success,
 *            ANT_CODE_INTERNAL if CMSG fails internally.
 */
static ant_code
_cmsg_proxy_call_cmsg_api (const cmsg_client *client, ProtobufCMessage *input_msg,
                           ProtobufCMessage **output_msg,
                           const cmsg_service_info *service_info)
{
    int ret;

    if (strcmp (service_info->input_msg_descriptor->name, "dummy") == 0)
    {
        ret = service_info->api_ptr (client, output_msg);
    }
    else if (strcmp (service_info->output_msg_descriptor->name, "dummy") == 0)
    {
        ret = service_info->api_ptr (client, input_msg);
    }
    else
    {
        ret = service_info->api_ptr (client, input_msg, output_msg);
    }

    if (ret == CMSG_RET_OK)
    {
        return ANT_CODE_OK;
    }
    else
    {
        return ANT_CODE_INTERNAL;
    }
}

/**
 * Helper function which takes the ProtobufCMessage received from calling
 * the CMSG API function, finds the error information set in the response,
 * and sets the HTTP response status based on the code returned from the
 * CMSG API.
 *
 * If the CMSG API has returned ANT_CODE_OK then the error information field is
 * unset from the protobuf message and hence will not be returned in the
 * JSON sent back to the user.
 *
 * @param http_status - Pointer to the http_status integer that should be set
 * @param msg - Pointer to the ProtobufCMessage received from the CMSG API call
 *
 * @returns 'true' if _error_info is updated with error message otherwise 'false'
 */
static bool
_cmsg_proxy_set_http_status (int *http_status, ProtobufCMessage **msg)
{
    const ProtobufCFieldDescriptor *field_desc = NULL;
    ProtobufCMessage **error_message_ptr = NULL;
    ant_result *error_message = NULL;
    bool ret = false;

    field_desc = protobuf_c_message_descriptor_get_field_by_name ((*msg)->descriptor,
                                                                  "_error_info");
    if (field_desc)
    {
        error_message_ptr = (ProtobufCMessage **) (((char *) *msg) + field_desc->offset);
    }
    else if (strcmp ((*msg)->descriptor->name, "ant_result") == 0)
    {
        error_message_ptr = msg;
    }

    error_message = (ant_result *) (*error_message_ptr);
    if (error_message && CMSG_IS_FIELD_PRESENT (error_message, code))
    {
        *http_status = ant_code_to_http_code_array[error_message->code];
        if (error_message->code == ANT_CODE_OK)
        {
            /* Unset the error info message from the protobuf message */
            CMSG_FREE_RECV_MSG (error_message);
            *error_message_ptr = NULL;
        }
        ret = true;
    }
    else
    {
        *http_status = HTTP_CODE_INTERNAL_SERVER_ERROR;
    }

    return ret;
}

/**
 * Generate a ANT_RESULT error output for an internal cmsg_proxy error
 *
 * @param code - ANT_CODE appropriate to the reason for failure
 * @param message - Descriptive error message
 * @param output_json - A pointer to a string that will store the output JSON data to
 *                      be sent with the HTTP response.
 * @param http_status - A pointer to an integer that will store the HTTP status code to
 *                      be sent with the HTTP response.
 */
void
_cmsg_proxy_generate_ant_result_error (ant_code code, char *message,
                                       int *http_status, char **output_json)
{
    ant_result error = ANT_RESULT_INIT;
    bool ret;

    CMSG_SET_FIELD_VALUE (&error, code, code);
    CMSG_SET_FIELD_PTR (&error, message, message);

    *http_status = ant_code_to_http_code_array[code];

    ret = _cmsg_proxy_protobuf2json_string ((ProtobufCMessage *) &error, output_json);

    if (!ret)
    {
        *http_status = HTTP_CODE_INTERNAL_SERVER_ERROR;
    }
}

/**
 * Generate the JSON string that should be returned to the web API caller.
 * If we are returning data to the user (i.e. not an error) then attempt to
 * strip the outer key of this data if the key is either the last substring
 * of the template URL, '_data' or '_error_info'.
 *
 * @param output_proto_message - The message returned from calling the CMSG API
 * @param output_json - Pointer to hold the JSON string that is returned
 * @param url - URL template that the CMSG proxy was called with
 */
static bool
_cmsg_proxy_generate_json_return (ProtobufCMessage *output_proto_message,
                                  char **output_json, const char *url)
{
    json_t *converted_json_object = NULL;
    const char *key;
    json_t *value;
    char *url_ending;
    bool ret = false;

    ret = _cmsg_proxy_protobuf2json_object (output_proto_message, &converted_json_object);
    if (!ret)
    {
        return false;
    }

    url_ending = strrchr (url, '/') + 1;

    json_object_foreach (converted_json_object, key, value)
    {
        /* Note that the "_error_info" field has been removed earlier on in the proxy
         * process for a successful API call */
        if ((strcmp (key, url_ending) == 0) || (strcmp (key, "_data") == 0) ||
            (strcmp (key, "_error_info") == 0))
        {
            *output_json = json_dumps (value, JSON_ENCODE_ANY | JSON_INDENT (4));
            json_decref (converted_json_object);
            return true;
        }
    }

    *output_json = json_dumps (converted_json_object, JSON_INDENT (4));
    json_decref (converted_json_object);
    return true;
}

#ifdef HAVE_COUNTERD
/**
 * Initialise service-specific counters
 *
 * @param service_info - CMSG proxy service
 */
static void
_proxy_session_counter_init (const cmsg_service_info *service_info)
{
    session_counter_info *session_counter;
    const char *service_name = service_info->service_descriptor->name;

    /* Create counter info hash table for the first time */
    if (proxy_session_counter_table == NULL)
    {
        /* Use the service descriptor as the key which is a "const" generated by protobuf-c.
         * So use direct pointer comparision for keys. */
        proxy_session_counter_table =
            g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL,
                                   (GDestroyNotify) _proxy_session_counter_info_delete);
    }

    /* Check if there exists counter info for the service. Otherwise create a new one */
    session_counter = g_hash_table_lookup (proxy_session_counter_table,
                                           SESSION_KEY (service_info));
    if (session_counter == NULL)
    {
        session_counter = _proxy_session_counter_info_new (service_name);
        if (session_counter != NULL)
        {
            g_hash_table_insert (proxy_session_counter_table,
                                 (gpointer) SESSION_KEY (service_info),
                                 (gpointer) session_counter);
        }
    }
}

/**
 * Uninitialise all service-specific counter
 */
static void
_proxy_session_counter_deinit_all (void)
{
    g_hash_table_destroy (proxy_session_counter_table);
    proxy_session_counter_table = NULL;
}

/**
 * Allocate new counter info and initialise
 *
 * @param service_name - CMSG proxy service name which is used to identify counter session
 *
 * @return newly allocated counter info or NULL on failure.
 */
static session_counter_info *
_proxy_session_counter_info_new (const char *service_name)
{
    session_counter_info *counter;
    char app_name[CNTRD_MAX_APP_NAME_LENGTH];
    int ret;

    counter = CMSG_PROXY_CALLOC (1, sizeof (session_counter_info));
    if (counter == NULL)
    {
        return NULL;
    }

    /* Choose counter session name using CMSG service name */
    snprintf (app_name, CNTRD_MAX_APP_NAME_LENGTH, "%s %s",
              CMSG_PROXY_COUNTER_APP_NAME_PREFIX, service_name);

    /* Initialise counters */
    ret = cntrd_app_init_app (app_name, CNTRD_APP_PERSISTENT, &counter->cntr_session);
    if (ret == CNTRD_APP_SUCCESS)
    {
        CMSG_PROXY_COUNTER_REGISTER (counter, "API Calls", cntr_api_calls);
        CMSG_PROXY_COUNTER_REGISTER (counter, "Error: Missing Client",
                                     cntr_error_missing_client);
        CMSG_PROXY_COUNTER_REGISTER (counter, "Error: Malformed Input",
                                     cntr_error_malformed_input);
        CMSG_PROXY_COUNTER_REGISTER (counter, "Error: API Call Failure",
                                     cntr_error_api_failure);
        CMSG_PROXY_COUNTER_REGISTER (counter, "Error: Missing Error_info",
                                     cntr_error_missing_error_info);
        CMSG_PROXY_COUNTER_REGISTER (counter, "Error: Protobuf to Json",
                                     cntr_error_protobuf_to_json);

        /* Tell cntrd not to destroy the counter data in the shared memory */
        cntrd_app_set_shutdown_instruction (app_name, CNTRD_SHUTDOWN_RESTART);
    }
    else
    {
        CMSG_PROXY_FREE (counter);
        counter = NULL;
    }

    return counter;
}

/**
 * Delete session counter
 */
static void
_proxy_session_counter_info_delete (session_counter_info *counter)
{
    if (counter)
    {
        /* Free counter session info but do not destroy counter data in the shared memory */
        cntrd_app_unInit_app (&counter->cntr_session, CNTRD_APP_PERSISTENT);

        CMSG_PROXY_FREE (counter);
    }
}

/**
 * Initialise couter
 */
static void
_cmsg_proxy_counter_init (void)
{
    char app_name[CNTRD_MAX_APP_NAME_LENGTH];
    int ret;

    /* If it's already initialised, return early */
    if (proxy_counter.cntr_session)
    {
        return;
    }

    /* Choose counter session name using CMSG service name */
    snprintf (app_name, CNTRD_MAX_APP_NAME_LENGTH, "%s",
              CMSG_PROXY_COUNTER_APP_NAME_PREFIX);

    /* Initialise counters */
    ret = cntrd_app_init_app (app_name, CNTRD_APP_PERSISTENT, &proxy_counter.cntr_session);
    if (ret == CNTRD_APP_SUCCESS)
    {
        CMSG_PROXY_COUNTER_REGISTER (&proxy_counter, "Unknown Service",
                                     cntr_unknown_service);
        CMSG_PROXY_COUNTER_REGISTER (&proxy_counter, "Service Info Loaded",
                                     cntr_service_info_loaded);
        CMSG_PROXY_COUNTER_REGISTER (&proxy_counter, "Service Info Unloaded",
                                     cntr_service_info_unloaded);
        CMSG_PROXY_COUNTER_REGISTER (&proxy_counter, "Client Creation Failed",
                                     cntr_client_create_failure);
        CMSG_PROXY_COUNTER_REGISTER (&proxy_counter, "Client Created", cntr_client_created);
        CMSG_PROXY_COUNTER_REGISTER (&proxy_counter, "Client Freed", cntr_client_freed);

        /* Tell cntrd not to destroy the counter data in the shared memory */
        cntrd_app_set_shutdown_instruction (app_name, CNTRD_SHUTDOWN_RESTART);
    }
}

/**
 * Deinitialise couter
 */
static void
_cmsg_proxy_counter_deinit (void)
{
    if (proxy_counter.cntr_session)
    {
        /* Free counter session info but do not destroy counter data in the shared memory */
        cntrd_app_unInit_app (&proxy_counter.cntr_session, CNTRD_APP_PERSISTENT);
        proxy_counter.cntr_session = NULL;
    }

    /* Clean up session counters */
    _proxy_session_counter_deinit_all ();
}
#endif /* HAVE_COUNTERD */

/**
 * Initialise the cmsg proxy library
 */
void
cmsg_proxy_init (void)
{
#ifdef CMSG_PROXY_MEM_DEBUG
    /* For developer debugging, turn on memory tracing */
    cmsg_proxy_mem_init (1);
#endif

#ifdef HAVE_COUNTERD
    /* Initialise counters */
    _cmsg_proxy_counter_init ();
#endif /* HAVE_COUNTERD */

    /* Create GNode proxy entries tree. */
    proxy_entries_tree = g_node_new (CMSG_PROXY_STRDUP (CMSG_API_VERSION_STR));

    _cmsg_proxy_library_handles_load ();
    _cmsg_proxy_clients_init ();
}

/**
 * Deinitialize the cmsg proxy library
 */
void
cmsg_proxy_deinit (void)
{
    _cmsg_proxy_service_info_deinit ();
    _cmsg_proxy_clients_deinit ();
    _cmsg_proxy_library_handles_close ();

#ifdef HAVE_COUNTERD
    /* Cleanup counters */
    _cmsg_proxy_counter_deinit ();
#endif /* HAVE_COUNTERD */
}

/**
 * Proxy an HTTP request into the AW+ CMSG internal API. Uses the HttpRules defined
 * for each rpc defined in the CMSG .proto files.
 *
 * @param url - URL the HTTP request is for.
 * @param http_verb - The HTTP verb sent with the HTTP request.
 * @param input_json - A string representing the JSON data sent with the HTTP request.
 * @param output_json - A pointer to a string that will store the output JSON data to.
 *                      be sent with the HTTP response. This pointer may be NULL if the
 *                      rpc does not send any response data and the pointer must be
 *                      freed by the caller (if it is non NULL).
 * @param http_status - A pointer to an integer that will store the HTTP status code to
 *                      be sent with the HTTP response.
 *
 * @return - true if the CMSG proxy actioned the request (i.e. it knew about the URL
 *           because it is defined on an rpc in the .proto files).
 *           false if the CMSG proxy performed no action (i.e. it could not map the URL
 *           to a CMSG API).
 */
bool
cmsg_proxy (const char *url, cmsg_http_verb http_verb, const char *input_json,
            char **output_json, int *http_status)
{
    const cmsg_service_info *service_info = NULL;
    const cmsg_client *client = NULL;
    ProtobufCMessage *input_proto_message = NULL;
    ProtobufCMessage *output_proto_message = NULL;
    ant_code result = ANT_CODE_OK;
    json_t *json_object = NULL;
    GList *url_parameters = NULL;
    char *message = NULL;
    json_error_t error;

    service_info = _cmsg_proxy_find_service_from_url_and_verb (url, http_verb,
                                                               &url_parameters);
    if (service_info == NULL)
    {
        /* The cmsg proxy does not know about this url and verb combination */
        g_list_free_full (url_parameters, _cmsg_proxy_free_url_parameter);
        CMSG_PROXY_COUNTER_INC (cntr_unknown_service);
        return false;
    }

    if (input_json)
    {
        _cmsg_proxy_json_object_create (&json_object, input_json, &error);

        if (!json_object)
        {
            /* No json object created, report the error */

            char *error_msg;

            if (CMSG_PROXY_ASPRINTF (&error_msg, "Invalid JSON: %s", error.text) < 0)
            {
                error_msg = NULL;
            }

            _cmsg_proxy_generate_ant_result_error (ANT_CODE_INVALID_ARGUMENT,
                                                   (error_msg) ? error_msg : "Invalid JSON",
                                                   http_status, output_json);

            CMSG_PROXY_FREE (error_msg);

            g_list_free_full (url_parameters, _cmsg_proxy_free_url_parameter);
            return true;
        }
    }

    _cmsg_proxy_parse_url_parameters (url_parameters, &json_object,
                                      service_info->input_msg_descriptor);

    g_list_free_full (url_parameters, _cmsg_proxy_free_url_parameter);

    client = _cmsg_proxy_find_client_by_service (service_info->service_descriptor);
    if (client == NULL)
    {
        /* This should not occur but check for it */
        *http_status = HTTP_CODE_INTERNAL_SERVER_ERROR;
        _cmsg_proxy_json_object_destroy (json_object);
        _cmsg_proxy_generate_ant_result_error (ANT_CODE_INTERNAL, NULL, http_status,
                                               output_json);
        CMSG_PROXY_SESSION_COUNTER_INC (service_info, cntr_error_missing_client);
        return true;
    }

    if (json_object)
    {
        result = _cmsg_proxy_convert_json_to_protobuf (json_object,
                                                       service_info->input_msg_descriptor,
                                                       &input_proto_message, &message);
        if (result != ANT_CODE_OK)
        {
            /* The JSON sent with the request is malformed */
            _cmsg_proxy_json_object_destroy (json_object);
            _cmsg_proxy_generate_ant_result_error (result, message, http_status,
                                                   output_json);
            free (message);
            CMSG_PROXY_SESSION_COUNTER_INC (service_info, cntr_error_malformed_input);
            return true;
        }
        free (message);
    }

    CMSG_PROXY_SESSION_COUNTER_INC (service_info, cntr_api_calls);

    result = _cmsg_proxy_call_cmsg_api (client, input_proto_message,
                                        &output_proto_message, service_info);
    if (result != ANT_CODE_OK)
    {
        /* Something went wrong calling the CMSG api */
        CMSG_FREE_RECV_MSG (input_proto_message);
        _cmsg_proxy_generate_ant_result_error (result, NULL, http_status, output_json);
        _cmsg_proxy_json_object_destroy (json_object);
        CMSG_PROXY_SESSION_COUNTER_INC (service_info, cntr_error_api_failure);
        return true;
    }

    CMSG_FREE_RECV_MSG (input_proto_message);

    if (!_cmsg_proxy_set_http_status (http_status, &output_proto_message))
    {
        syslog (LOG_ERR, "_error_info is not set for %s", service_info->url_string);
        CMSG_PROXY_SESSION_COUNTER_INC (service_info, cntr_error_missing_error_info);
    }

    if (output_proto_message)
    {
        if (!_cmsg_proxy_generate_json_return (output_proto_message, output_json,
                                               service_info->url_string))
        {
            /* This should not occur (the ProtobufCMessage structure returned
             * by the CMSG api should always be well formed) but check for it */
            *http_status = HTTP_CODE_INTERNAL_SERVER_ERROR;
            CMSG_PROXY_SESSION_COUNTER_INC (service_info, cntr_error_protobuf_to_json);
        }
        CMSG_FREE_RECV_MSG (output_proto_message);
    }

    _cmsg_proxy_json_object_destroy (json_object);
    return true;
}
